var documenterSearchIndex = {"docs":
[{"location":"tutorials/pointnet/#PointNet-Classification","page":"PointNet classication","title":"PointNet Classification","text":"","category":"section"},{"location":"tutorials/pointnet/","page":"PointNet classication","title":"PointNet classication","text":"Classification of PointCloud structure using PointNet model","category":"page"},{"location":"tutorials/pointnet/","page":"PointNet classication","title":"PointNet classication","text":"note: Note\nFor visualization purpose we will require to install Makie and compatible backend (GLMakie or WGLMakie). To install it simply run ] add Makie in the julia prompt.","category":"page"},{"location":"tutorials/pointnet/","page":"PointNet classication","title":"PointNet classication","text":"using Flux3D, Flux, Makie, CUDA\nusing Flux: onehotbatch, onecold, onehot, crossentropy\nusing Statistics: mean\nusing Base.Iterators: partition\n\nMakie.AbstractPlotting.inline!(false)\nMakie.AbstractPlotting.set_theme!(show_axis = false)","category":"page"},{"location":"tutorials/pointnet/#Defining-arguments-for-use-in-training.","page":"PointNet classication","title":"Defining arguments for use in training.","text":"","category":"section"},{"location":"tutorials/pointnet/","page":"PointNet classication","title":"PointNet classication","text":"batch_size - batch size of of training data to be passed while training.\nlr - learing rate for the optimization.\nepochs - number of episodes for training the classification model.\nnum_classes - number of classes in labels of dataset.\nnpoints - number of points in each PointCloud to be returned by dataset.","category":"page"},{"location":"tutorials/pointnet/","page":"PointNet classication","title":"PointNet classication","text":"batch_size = 32\nlr = 3e-4\nepochs = 5\nnum_classes = 10 #possible values {10,40}\nnpoints = 1024","category":"page"},{"location":"tutorials/pointnet/#ModelNet10-Dataset","page":"PointNet classication","title":"ModelNet10 Dataset","text":"","category":"section"},{"location":"tutorials/pointnet/","page":"PointNet classication","title":"PointNet classication","text":"This package has dataset wrapper for ModelNet10/40 which makes it easy to load and preprocess ModelNet dataset. In this example we will using ModelNet10 but we can also use ModelNet40 with minor tweak in num_classes args.","category":"page"},{"location":"tutorials/pointnet/","page":"PointNet classication","title":"PointNet classication","text":"We can construct ModelNet10 dataset by passing:","category":"page"},{"location":"tutorials/pointnet/","page":"PointNet classication","title":"PointNet classication","text":"mode=:pointcloud - for returning PointCloud variant of dataset\nnpoints - no. of points in each PointCloud.\ntransforms  - Transforms to be applied before return specified PointCloud.\ntrain   - Bool to indicate training or testing split.","category":"page"},{"location":"tutorials/pointnet/","page":"PointNet classication","title":"PointNet classication","text":"Detailed list of available arguments can be found in ModelNet section.","category":"page"},{"location":"tutorials/pointnet/","page":"PointNet classication","title":"PointNet classication","text":"dset = ModelNet10.dataset(;\n    mode = :pointcloud,\n    npoints = npoints,\n    transform = NormalizePointCloud(),\n)\nval_dset = ModelNet10.dataset(;\n    mode = :pointcloud,\n    train = false,\n    npoints = npoints,\n    transform = NormalizePointCloud(),\n)","category":"page"},{"location":"tutorials/pointnet/#Visualizing-the-dataset","page":"PointNet classication","title":"Visualizing the dataset","text":"","category":"section"},{"location":"tutorials/pointnet/","page":"PointNet classication","title":"PointNet classication","text":"we can access the dataset by correspond index like dset[1] which will return a ModelNet10 DataPoint and following information idx: 1, data: PointCloud{Float32}, ground_truth: 1 (bathtub).","category":"page"},{"location":"tutorials/pointnet/","page":"PointNet classication","title":"PointNet classication","text":"For the visulizing the corresponding datapoint we can use visulize","category":"page"},{"location":"tutorials/pointnet/","page":"PointNet classication","title":"PointNet classication","text":"visualize(dset[11], markersize = 0.1)","category":"page"},{"location":"tutorials/pointnet/","page":"PointNet classication","title":"PointNet classication","text":"<p align=\"center\">\n    <img width=256 height=256 src=\"../../assets/chair.png\">\n</p>","category":"page"},{"location":"tutorials/pointnet/#Preparing-Dataloader-for-training.","page":"PointNet classication","title":"Preparing Dataloader for training.","text":"","category":"section"},{"location":"tutorials/pointnet/","page":"PointNet classication","title":"PointNet classication","text":"data = [dset[i].data.points for i = 1:length(dset)]\nlabels =\n    onehotbatch([dset[i].ground_truth for i = 1:length(dset)], 1:num_classes)\n\nvalX = cat([val_dset[i].data.points for i = 1:length(val_dset)]..., dims = 3)\nvalY = onehotbatch(\n    [val_dset[i].ground_truth for i = 1:length(val_dset)],\n    1:num_classes,\n)\n\nTRAIN = [\n    (cat(data[i]..., dims = 3), labels[:, i])\n    for i in partition(1:length(data), batch_size)\n]\nVAL = (valX, valY)","category":"page"},{"location":"tutorials/pointnet/#Defining-3D-model","page":"PointNet classication","title":"Defining 3D model","text":"","category":"section"},{"location":"tutorials/pointnet/","page":"PointNet classication","title":"PointNet classication","text":"Flux3D has predefined PointNet classification model which can be used to train PointCloud dataset","category":"page"},{"location":"tutorials/pointnet/","page":"PointNet classication","title":"PointNet classication","text":"m = PointNet(num_classes)","category":"page"},{"location":"tutorials/pointnet/#Defining-loss-and-validating-objectives","page":"PointNet classication","title":"Defining loss and validating objectives","text":"","category":"section"},{"location":"tutorials/pointnet/","page":"PointNet classication","title":"PointNet classication","text":"loss(x, y) = crossentropy(m(x), y)\naccuracy(x, y) =\n    mean(onecold(cpu(m(x)), 1:num_classes) .== onecold(cpu(y), 1:num_classes))","category":"page"},{"location":"tutorials/pointnet/#Defining-learning-rate-and-optimizer","page":"PointNet classication","title":"Defining learning rate and optimizer","text":"","category":"section"},{"location":"tutorials/pointnet/","page":"PointNet classication","title":"PointNet classication","text":"opt = Flux.ADAM(lr)","category":"page"},{"location":"tutorials/pointnet/#Using-GPU-for-fast-training-[**Optional**]","page":"PointNet classication","title":"Using GPU for fast training [Optional]","text":"","category":"section"},{"location":"tutorials/pointnet/","page":"PointNet classication","title":"PointNet classication","text":"We can convert the 3D model to GPU or CPU usinggpu and cpu, and also changing the dataloader using same function","category":"page"},{"location":"tutorials/pointnet/","page":"PointNet classication","title":"PointNet classication","text":"m = m |> gpu\nTRAIN = TRAIN |> gpu\nVAL = VAL |> gpu","category":"page"},{"location":"tutorials/pointnet/#Training-the-3D-model","page":"PointNet classication","title":"Training the 3D model","text":"","category":"section"},{"location":"tutorials/pointnet/","page":"PointNet classication","title":"PointNet classication","text":"ps = params(m)\nfor epoch = 1:epochs\n    running_loss = 0\n    for d in TRAIN\n        gs = gradient(ps) do\n            training_loss = loss(d...)\n            running_loss += training_loss\n            return training_loss\n        end\n        Flux.update!(opt, ps, gs)\n    end\n    print(\"Epoch: $(epoch), epoch_loss: $(running_loss), accuracy: $(accuracy(VAL...))\\n\")\nend\n@show accuracy(VAL...)","category":"page"},{"location":"tutorials/pointnet/","page":"PointNet classication","title":"PointNet classication","text":"","category":"page"},{"location":"tutorials/pointnet/","page":"PointNet classication","title":"PointNet classication","text":"This page was generated using Literate.jl.","category":"page"},{"location":"api/conversions/","page":"Conversions","title":"Conversions","text":"CurrentModule = Flux3D","category":"page"},{"location":"api/conversions/#Inter-Conversion-between-different-3D-Structure","page":"Conversions","title":"Inter-Conversion between different 3D Structure","text":"","category":"section"},{"location":"api/conversions/","page":"Conversions","title":"Conversions","text":"Converting a 3D Structure to any other Structure can be achieve using the respective 3D structure constructor. We can also use transforms for inter-conversion between different structure.","category":"page"},{"location":"api/conversions/","page":"Conversions","title":"Conversions","text":"Modules = [Flux3D]\nPages = [\"conversions.jl\"]","category":"page"},{"location":"api/conversions/#Flux3D.PointCloud","page":"Conversions","title":"Flux3D.PointCloud","text":"PointCloud(v::VoxelGrid, npoints::Int = 1000; thresh::Number = 0.5f0, algo = :MarchingCubes)\n\nInitialize PointCloud from the VoxelGrid Structures having npoints.\n\nthresh is the threshold from which to make binary voxels, and algo is the mode to be used to convert binary voxels. Available algo are [:Exact, :MarchingCubes, :MarchingTetrahedra, :NaiveSurfaceNets].\n\nSee also: VoxelGridToPointCloud\n\n\n\n\n\n","category":"type"},{"location":"api/conversions/#Flux3D.PointCloud-2","page":"Conversions","title":"Flux3D.PointCloud","text":"PointCloud(m::TriMesh, npoints::Int = 1000)\n\nInitialize PointCloud, having npoints, from the TriMesh structure.\n\nSee also: TriMeshToPointCloud\n\n\n\n\n\n","category":"type"},{"location":"api/conversions/#Flux3D.TriMesh","page":"Conversions","title":"Flux3D.TriMesh","text":"TriMesh(p::PointCloud, res::Int = 32; algo = :MarchingCubes)\n\nInitialize TriMesh from PointCloud structures having specified resolution.\n\nalgo is the mode to be used to convert binary voxels. Available algo are [:Exact, :MarchingCubes, :MarchingTetrahedra, :NaiveSurfaceNets].\n\nSee also: PointCloudToTriMesh\n\n\n\n\n\n","category":"type"},{"location":"api/conversions/#Flux3D.TriMesh-Tuple{VoxelGrid}","page":"Conversions","title":"Flux3D.TriMesh","text":"TriMesh(v::VoxelGrid; thresh::Number = 0.5f0, algo = :MarchingCubes)\n\nInitialize TriMesh from the VoxelGrid structures.\n\nthreshold is the threshold from which to make binary voxels, and algo is the mode to be used to convert binary voxels. Available algo are [:Exact, :MarchingCubes, :MarchingTetrahedra, :NaiveSurfaceNets].\n\nSee also: VoxelGridToTriMesh\n\n\n\n\n\n","category":"method"},{"location":"api/conversions/#Flux3D.VoxelGrid","page":"Conversions","title":"Flux3D.VoxelGrid","text":"VoxelGrid(p::PointCloud, res::Int = 32)\n\nInitialize VoxelGrid, having specified resolution, from PointCloud Structure.\n\nSee also: PointCloudToVoxelGrid\n\n\n\n\n\n","category":"type"},{"location":"api/conversions/#Flux3D.VoxelGrid-2","page":"Conversions","title":"Flux3D.VoxelGrid","text":"VoxelGrid(m::TriMesh, res::Int = 32)\n\nInitialize VoxelGrid, having specified resolution, from TriMesh Structure.\n\nSee also: TriMeshToVoxelGrid\n\n\n\n\n\n","category":"type"},{"location":"tutorials/fit_mesh/#Supervised-3D-Mesh-Reconstruction","page":"Supervised 3D reconstruction","title":"Supervised 3D Mesh Reconstruction","text":"","category":"section"},{"location":"tutorials/fit_mesh/#Problem-Description:","page":"Supervised 3D reconstruction","title":"Problem Description:","text":"","category":"section"},{"location":"tutorials/fit_mesh/","page":"Supervised 3D reconstruction","title":"Supervised 3D reconstruction","text":"We are given an initial source shape (sphere in this case) and we want to deform this source shape to fit target shape (dolphin in this case). For this demonstration, we will be using Triangle Mesh for the representation of source and target shape.","category":"page"},{"location":"tutorials/fit_mesh/","page":"Supervised 3D reconstruction","title":"Supervised 3D reconstruction","text":"Triangle Mesh has two main components, vertices and faces. Deformation of source shape to fit target shape can be achieved by offsetting source's vertices to fit target surface. Also, the number of vertices and faces is not equal in source and target shape.","category":"page"},{"location":"tutorials/fit_mesh/","page":"Supervised 3D reconstruction","title":"Supervised 3D reconstruction","text":"note: Note\nFor visualization purpose we will require to install Makie and compatible backend (GLMakie or WGLMakie). To install it simply run ] add Makie in the julia prompt.","category":"page"},{"location":"tutorials/fit_mesh/","page":"Supervised 3D reconstruction","title":"Supervised 3D reconstruction","text":"using Flux3D, Zygote, Flux, FileIO, Statistics, Plots\nusing AbstractPlotting, GLMakie\n\nFlux3D.AbstractPlotting.inline!(true)\nFlux3D.AbstractPlotting.set_theme!(show_axis = false)","category":"page"},{"location":"tutorials/fit_mesh/#Downloading-obj-file-of-sphere-and-dolphin","page":"Supervised 3D reconstruction","title":"Downloading obj file of sphere and dolphin","text":"","category":"section"},{"location":"tutorials/fit_mesh/","page":"Supervised 3D reconstruction","title":"Supervised 3D reconstruction","text":"download(\"https://github.com/nirmalsuthar/public_files/raw/master/dolphin.obj\",\n         \"dolphin.obj\")\ndownload(\"https://github.com/nirmalsuthar/public_files/raw/master/sphere.obj\",\n         \"sphere.obj\")","category":"page"},{"location":"tutorials/fit_mesh/#Loading-Triangle-Mesh","page":"Supervised 3D reconstruction","title":"Loading Triangle Mesh","text":"","category":"section"},{"location":"tutorials/fit_mesh/","page":"Supervised 3D reconstruction","title":"Supervised 3D reconstruction","text":"Triangle Mesh is handled by TriMesh in Flux3D. TriMesh also supports batched format, namely padded, packed and list, which allow us to use fast batched operations. We can load TriMesh with load_trimesh function (supports obj, stl, ply, off and 2DM)","category":"page"},{"location":"tutorials/fit_mesh/","page":"Supervised 3D reconstruction","title":"Supervised 3D reconstruction","text":"dolphin = load_trimesh(\"dolphin.obj\")\nsrc = load_trimesh(\"sphere.obj\")","category":"page"},{"location":"tutorials/fit_mesh/#Preprocessing-data","page":"Supervised 3D reconstruction","title":"Preprocessing data","text":"","category":"section"},{"location":"tutorials/fit_mesh/","page":"Supervised 3D reconstruction","title":"Supervised 3D reconstruction","text":"Preprocessing tgt (dolphin), such that its mean is zero and also scale it according to the bounding box of src (sphere), So that src can converge at greater speed.","category":"page"},{"location":"tutorials/fit_mesh/","page":"Supervised 3D reconstruction","title":"Supervised 3D reconstruction","text":"tgt = deepcopy(dolphin)\nverts = get_verts_packed(tgt)\ncenter = mean(verts, dims=2)\nverts = verts .- center\nscale = maximum(abs.(verts))\nverts = verts ./ scale\ntgt._verts_packed = verts","category":"page"},{"location":"tutorials/fit_mesh/#Visualizing-TriMesh","page":"Supervised 3D reconstruction","title":"Visualizing TriMesh","text":"","category":"section"},{"location":"tutorials/fit_mesh/","page":"Supervised 3D reconstruction","title":"Supervised 3D reconstruction","text":"We will use visualize function for visualizing TriMesh. This function uses Makie for plotting. In fact, we can also visualize PointCloud using this function, which makes this function handy dealing with different 3D format.","category":"page"},{"location":"tutorials/fit_mesh/","page":"Supervised 3D reconstruction","title":"Supervised 3D reconstruction","text":"Flux3D.AbstractPlotting.vbox(visualize(src), visualize(tgt))","category":"page"},{"location":"tutorials/fit_mesh/","page":"Supervised 3D reconstruction","title":"Supervised 3D reconstruction","text":"<p align=\"center\">\n    <img width=480 height=270 src=\"../../assets/fitmesh_initial.png\">\n</p>","category":"page"},{"location":"tutorials/fit_mesh/#Defining-loss-objective","page":"Supervised 3D reconstruction","title":"Defining loss objective","text":"","category":"section"},{"location":"tutorials/fit_mesh/","page":"Supervised 3D reconstruction","title":"Supervised 3D reconstruction","text":"Starting from the src mesh, we will deform src mesh by offsetting its vertices (by offset array), such that new deformed mesh is close to target mesh. Therefore, our loss function will optimize the offset array. We will be using the following metrics to define loss objective:","category":"page"},{"location":"tutorials/fit_mesh/","page":"Supervised 3D reconstruction","title":"Supervised 3D reconstruction","text":"chamfer_distance - the distance between the deformed mesh and target mesh, which is calculated by taking randomly 5000 points from the surface of each mesh and calculating chamfer_distance between these two pointcloud.\nlaplacian_loss - also known as Laplacian smoothing will act as a regularizer.\nedge_loss - this will minimize edges length in deformed mesh, also act as a regularizer.","category":"page"},{"location":"tutorials/fit_mesh/","page":"Supervised 3D reconstruction","title":"Supervised 3D reconstruction","text":"function loss_dolphin(x::AbstractArray, src::TriMesh, tgt::TriMesh)\n    src = Flux3D.offset(src, x)\n    loss1 = chamfer_distance(src, tgt, 5000)\n    loss2 = laplacian_loss(src)\n    loss3 = edge_loss(src)\n    return loss1 + 0.1*loss2 + loss3\nend","category":"page"},{"location":"tutorials/fit_mesh/#Defining-learning-rate-and-optimizer","page":"Supervised 3D reconstruction","title":"Defining learning rate and optimizer","text":"","category":"section"},{"location":"tutorials/fit_mesh/","page":"Supervised 3D reconstruction","title":"Supervised 3D reconstruction","text":"lr = 1.0\nopt = Flux.Optimise.Momentum(lr, 0.9)\n_offset = zeros(Float32, size(get_verts_packed(src))...)","category":"page"},{"location":"tutorials/fit_mesh/#Using-GPU-for-fast-training-[**Optional**]","page":"Supervised 3D reconstruction","title":"Using GPU for fast training [Optional]","text":"","category":"section"},{"location":"tutorials/fit_mesh/","page":"Supervised 3D reconstruction","title":"Supervised 3D reconstruction","text":"We can convert the TriMesh structure to GPU or CPU usinggpu and cpu function which is exactly the same syntax as Flux.","category":"page"},{"location":"tutorials/fit_mesh/","page":"Supervised 3D reconstruction","title":"Supervised 3D reconstruction","text":"tgt = tgt |> gpu\nsrc = src |> gpu\n_offset = _offset |> gpu","category":"page"},{"location":"tutorials/fit_mesh/#Optimizing-the-offset-array","page":"Supervised 3D reconstruction","title":"Optimizing the offset array","text":"","category":"section"},{"location":"tutorials/fit_mesh/","page":"Supervised 3D reconstruction","title":"Supervised 3D reconstruction","text":"We first initialize offset array as zeros, hence deformed mesh is equivalent to src mesh (sphere). Next, we calculate loss using this offset array and we compute derivatives wrt. offset array and finally optimize the array.","category":"page"},{"location":"tutorials/fit_mesh/","page":"Supervised 3D reconstruction","title":"Supervised 3D reconstruction","text":"@info(\"Training...\")\nθ = Zygote.Params([_offset])\nfor itr in 1:2001\n    gs = gradient(θ) do\n        loss_dolphin(_offset, src, tgt)\n    end\n    Flux.update!(opt, _offset, gs[_offset])\n    if (itr%10 == 1)\n        loss = loss_dolphin(_offset, src, tgt)\n        @show itr, loss\n        save(\"src_$(itr).png\", visualize(Flux3D.offset(src, _offset)))\n    end\nend\n\nanim = @animate for i ∈ 1:8\n    Plots.plot(load(\"src_$(1+250*(i-1)).png\"), showaxis=false)\nend\ngif(anim, \"src_deform.gif\", fps = 2)","category":"page"},{"location":"tutorials/fit_mesh/","page":"Supervised 3D reconstruction","title":"Supervised 3D reconstruction","text":"<p align=\"center\">\n\n    <img width=256 height=256 src=\"../../assets/fitmesh_anim.gif\">\n</p>","category":"page"},{"location":"tutorials/fit_mesh/#Postprocessing-the-predicted-mesh","page":"Supervised 3D reconstruction","title":"Postprocessing the predicted mesh","text":"","category":"section"},{"location":"tutorials/fit_mesh/","page":"Supervised 3D reconstruction","title":"Supervised 3D reconstruction","text":"We create a new TriMesh by offsetting src by final offset array and scale up the finalmesh by the same scaling factor we scale down tgt, such that finalmesh has similar bounding box as dolphin mesh.","category":"page"},{"location":"tutorials/fit_mesh/","page":"Supervised 3D reconstruction","title":"Supervised 3D reconstruction","text":"final_mesh = Flux3D.offset(src, _offset)\nfinal_mesh = Flux3D.scale!(final_mesh, scale)","category":"page"},{"location":"tutorials/fit_mesh/#Saving-the-final_mesh","page":"Supervised 3D reconstruction","title":"Saving the final_mesh","text":"","category":"section"},{"location":"tutorials/fit_mesh/","page":"Supervised 3D reconstruction","title":"Supervised 3D reconstruction","text":"Flux3D provide IO function save_trimesh  to save TriMesh (supports obj, stl, ply, off and 2DM)","category":"page"},{"location":"tutorials/fit_mesh/","page":"Supervised 3D reconstruction","title":"Supervised 3D reconstruction","text":"save_trimesh(\"results/final_mesh.off\", final_mesh)\nsave(\"results/final_mesh.png\", visualize(final_mesh))\nFlux3D.AbstractPlotting.vbox(visualize(final_mesh), visualize(dolphin))","category":"page"},{"location":"tutorials/fit_mesh/","page":"Supervised 3D reconstruction","title":"Supervised 3D reconstruction","text":"<p align=\"center\">\n    <img width=480 height=270 src=\"../../assets/fitmesh_final.png\">\n</p>","category":"page"},{"location":"tutorials/fit_mesh/#Finally..","page":"Supervised 3D reconstruction","title":"Finally..","text":"","category":"section"},{"location":"tutorials/fit_mesh/","page":"Supervised 3D reconstruction","title":"Supervised 3D reconstruction","text":"Look into the other examples in examples/\nRead more the TriMesh in TriMesh section in documentation and","category":"page"},{"location":"tutorials/fit_mesh/","page":"Supervised 3D reconstruction","title":"Supervised 3D reconstruction","text":"Metrics/Transforms section for manipulating TriMesh and computing standard metrics.","category":"page"},{"location":"tutorials/fit_mesh/","page":"Supervised 3D reconstruction","title":"Supervised 3D reconstruction","text":"","category":"page"},{"location":"tutorials/fit_mesh/","page":"Supervised 3D reconstruction","title":"Supervised 3D reconstruction","text":"This page was generated using Literate.jl.","category":"page"},{"location":"rep/pointcloud/","page":"PointCloud","title":"PointCloud","text":"CurrentModule = Flux3D","category":"page"},{"location":"rep/pointcloud/#PointCloud-Structure","page":"PointCloud","title":"PointCloud Structure","text":"","category":"section"},{"location":"rep/pointcloud/#PointCloud-Constructor","page":"PointCloud","title":"PointCloud Constructor","text":"","category":"section"},{"location":"rep/pointcloud/","page":"PointCloud","title":"PointCloud","text":"Modules = [Flux3D]\nPages = [\"src/rep/pcloud.jl\"]","category":"page"},{"location":"rep/pointcloud/#Flux3D.PointCloud","page":"PointCloud","title":"Flux3D.PointCloud","text":"PointCloud\n\nInitialize PointCloud representation.\n\npoints should be Array of size (D, N, B) where N is the number of points, D is dimensionality of each points (i.e. D=2 or D=3) and B is the batch size of PointCloud. normals is optional field, if given should be Array of size (D, N, B) where N and B should match with the N and B of points and D=2 or D=3 (i.e. normals for 2D and 3D PointCloud respectively).\n\nFields:\n\npoints      - Points that makes up whole PointCloud.\nnormals     - Normals of each points in PointCloud.\n\nAvailable Contructor:\n\nPointCloud(points, normals=nothing)\nPointCloud(;points, normals=nothing)\nPointCloud(pcloud::PointCloud)\n\n\n\n\n\n","category":"type"},{"location":"rep/pointcloud/#Flux3D.npoints-Tuple{PointCloud}","page":"PointCloud","title":"Flux3D.npoints","text":"npoints(p::PointCloud)\n\nReturns the size of PointCloud.\n\n\n\n\n\n","category":"method"},{"location":"api/utils/","page":"Helper function","title":"Helper function","text":"CurrentModule = Flux3D","category":"page"},{"location":"api/utils/#Helper-function-and-General-Utilities","page":"Helper function","title":"Helper function and General Utilities","text":"","category":"section"},{"location":"api/utils/#List-of-all-helper-functions-and-utilities","page":"Helper function","title":"List of all helper functions and utilities","text":"","category":"section"},{"location":"api/utils/","page":"Helper function","title":"Helper function","text":"Pages = [\"utils.md\"]","category":"page"},{"location":"api/utils/","page":"Helper function","title":"Helper function","text":"","category":"page"},{"location":"api/utils/#TriMesh-Utilities","page":"Helper function","title":"TriMesh Utilities","text":"","category":"section"},{"location":"api/utils/","page":"Helper function","title":"Helper function","text":"Modules = [Flux3D]\nPages = [\"mesh_func.jl\"]","category":"page"},{"location":"api/utils/#Flux3D.normalize!-Tuple{TriMesh}","page":"Helper function","title":"Flux3D.normalize!","text":"normalize!(m::TriMesh)\n\nNormalize each mesh in TriMesh m with mean centered at origin and unit standard deviation and overwrite the m with normalized TriMesh.\n\nSee also: normalize\n\nExamples:\n\njulia> m = load_trimesh(\"teapot.obj\")\njulia> normalize!(m)\n\n\n\n\n\n","category":"method"},{"location":"api/utils/#Flux3D.normalize-Tuple{TriMesh}","page":"Helper function","title":"Flux3D.normalize","text":"normalize(m::TriMesh)\n\nNormalize each mesh in TriMesh m with mean centered at origin and unit standard deviation\n\nSee also: normalize!\n\nExamples:\n\njulia> m = load_trimesh(\"teapot.obj\")\njulia> m = normalize(m)\n\n\n\n\n\n","category":"method"},{"location":"api/utils/#Flux3D.offset-Tuple{TriMesh,AbstractArray{var\"#s86\",2} where var\"#s86\"<:Number}","page":"Helper function","title":"Flux3D.offset","text":"offset(m::TriMesh, offset_verts_packed::AbstractArray{<:Number,2})\n\nAdd offset to the vertices of the TriMesh m by offset vertices offset_verts_packed.\n\nSee also: offset!\n\nExamples:\n\njulia> m = load_trimesh(\"teapot.obj\")\njulia> offset_verts = ones(get_verts_packed(m))\njulia> m = offset(m, offset_verts)\n\n\n\n\n\n","category":"method"},{"location":"api/utils/#Flux3D.realign!-Tuple{TriMesh,AbstractArray{Float32,2},AbstractArray{Float32,2}}","page":"Helper function","title":"Flux3D.realign!","text":"realign!(src::TriMesh, tgt::TriMesh)\nrealign!(src::TriMesh, tgt_min::AbstractArray{<:Number,2}, tgt_max::AbstractArray{<:Number,2})\n\nRe-Align the TriMesh src with the axis aligned bounding box of mesh at index in TriMesh tgt and overwrite src with re-aligned TriMesh.\n\nSee also: realign\n\nExamples:\n\njulia> src = load_trimesh(\"teapot.obj\")\njulia> tgt = scale(src, 2.0)\njulia> realign!(src, tgt)\n\n\n\n\n\n","category":"method"},{"location":"api/utils/#Flux3D.realign-Tuple{TriMesh,AbstractArray{var\"#s85\",2} where var\"#s85\"<:Number,AbstractArray{var\"#s84\",2} where var\"#s84\"<:Number}","page":"Helper function","title":"Flux3D.realign","text":"realign(src::TriMesh, tgt::TriMesh, index::Integer=1)\nrealign(src::TriMesh, tgt_min::AbstractArray{<:Number,2}, tgt_max::AbstractArray{<:Number,2})\n\nRe-Align the TriMesh src with the axis aligned bounding box of mesh at index in TriMesh tgt.\n\nSee also: realign\n\nExamples:\n\njulia> src = load_trimesh(\"teapot.obj\")\njulia> tgt = scale(src, 2.0)\njulia> src = realign(src, tgt)\n\n\n\n\n\n","category":"method"},{"location":"api/utils/#Flux3D.rotate!-Tuple{TriMesh,AbstractArray{Float32,2}}","page":"Helper function","title":"Flux3D.rotate!","text":"rotate!(m::TriMesh, rotmat::AbstractArray{<:Number,2})\nrotate!(m::TriMesh, rotmat::AbstractArray{<:Number,3})\n\nRotate the TriMesh m by rotation matrix rotmat and overwrite m with rotated TriMesh.\n\nRotation matrix rotmat should be of size (3,3) or (3,3,B) where B is the batch size of TriMesh.\n\nSee also: rotate\n\nExamples:\n\njulia> m = load_trimesh(\"teapot.obj\")\njulia> rotmat = rand(3,3)\njulia> rotate!(m, rotmat)\n\n\n\n\n\n","category":"method"},{"location":"api/utils/#Flux3D.rotate-Tuple{TriMesh,AbstractArray{var\"#s86\",N} where N where var\"#s86\"<:Number}","page":"Helper function","title":"Flux3D.rotate","text":"rotate(m::TriMesh, rotmat::AbstractArray{<:Number,2})\n\nRotate the TriMesh m by rotation matrix rotmat.\n\nRotation matrix rotmat should be of size (3,3)\n\nSee also: rotate!\n\nExamples:\n\njulia> m = load_trimesh(\"teapot.obj\")\njulia> rotmat = rand(3,3)\njulia> m = rotate(m, rotmat)\n\n\n\n\n\n","category":"method"},{"location":"api/utils/#Flux3D.sample_points-Union{Tuple{TriMesh{T,R,S}}, Tuple{S}, Tuple{R}, Tuple{T}, Tuple{TriMesh{T,R,S},Int64}} where S where R where T","page":"Helper function","title":"Flux3D.sample_points","text":"sample_points(m::TriMesh, num_samples::Int=5000; returns_normals::Bool=false, eps::Number = 1e-6)\n\nUniformly samples num_samples points from the surface of TriMesh m.\n\nreturns_normals is optional keyword argument, to returns normals from respective faces of samples. eps is optional keyword argument for a small number to prevent division by zero for small surface areas.\n\nExamples:\n\njulia> m = load_trimesh(\"teapot.obj\")\njulia> points = sample_points(m, 5000)\njulia> points, normals = sample_points(m, 5000; returns_normals=true)\n\n\n\n\n\n","category":"method"},{"location":"api/utils/#Flux3D.scale!-Tuple{TriMesh,Float32}","page":"Helper function","title":"Flux3D.scale!","text":"scale!(m::TriMesh, factor::Number)\nscale!(m::TriMesh, factor::AbstractArray{<:Number})\n\nScale the TriMesh m by scaling factor factor and overwrite m with scaled TriMesh. If factor is array of size (3, ), then TriMesh will be scale by scaling factor of respective dimension.\n\nScaling factor factor (each element in case of array) should be strictly greater than 0.0.\n\nSee also: scale\n\nExamples:\n\njulia> m = load_trimesh(\"teapot.obj\")\njulia> scale!(m, 1.0)\njulia> scale!(m, [1.0, 1.0, 1.0])\n\n\n\n\n\n","category":"method"},{"location":"api/utils/#Flux3D.scale-Tuple{TriMesh,Union{Float32, AbstractArray{Float32,N} where N}}","page":"Helper function","title":"Flux3D.scale","text":"scale(m::TriMesh, factor::Number)\nscale(m::TriMesh, factor::AbstractArray{<:Number})\n\nScale the TriMesh m by scaling factor factor. If factor is array of size (3, ), then TriMesh will be scaleby scaling factor of respective dimension.\n\nScaling factor factor (each element in case of array) should be strictly greater than 0.0.\n\nSee also: scale!\n\nExamples:\n\njulia> m = load_trimesh(\"teapot.obj\")\njulia> m = scale(m, 1.0)\njulia> m = scale!(m, [1.0, 1.0, 1.0])\n\n\n\n\n\n","category":"method"},{"location":"api/utils/#Flux3D.translate!-Tuple{TriMesh,Float32}","page":"Helper function","title":"Flux3D.translate!","text":"translate!(m::TriMesh, vector::Number)\ntranslate!(m::TriMesh, vector::AbstractArray{<:Number})\n\nTranslate the TriMesh m by translating vector vector and overwrite m with translated TriMesh. If vector is a number, then TriMesh will be translated by same number in all dimension.\n\nSee also: translate\n\nExamples:\n\njulia> m = load_trimesh(\"teapot.obj\")\njulia> translate!(m, 0.0)\njulia> translate!(m, [0.0, 0.0, 0.0])\n\n\n\n\n\n","category":"method"},{"location":"api/utils/#Flux3D.translate-Tuple{TriMesh,Vararg{Any,N} where N}","page":"Helper function","title":"Flux3D.translate","text":"translate(m::TriMesh, vector::Number)\ntranslate(m::TriMesh, vector::AbstractArray{<:Number})\n\nTranslate the TriMesh m by translating vector vector. If vector is a number, then TriMesh will be translated by same number in all dimension.\n\nSee also: translate!\n\nExamples:\n\njulia> m = load_trimesh(\"teapot.obj\")\njulia> m = translate(m, 0.0)\njulia> m = translate(m, [0.0, 0.0, 0.0])\n\n\n\n\n\n","category":"method"},{"location":"api/utils/","page":"Helper function","title":"Helper function","text":"","category":"page"},{"location":"api/utils/#PointCloud-Utilities","page":"Helper function","title":"PointCloud Utilities","text":"","category":"section"},{"location":"api/utils/","page":"Helper function","title":"Helper function","text":"Modules = [Flux3D]\nPages = [\"pcloud_func.jl\"]","category":"page"},{"location":"api/utils/#Flux3D.normalize!-Tuple{PointCloud}","page":"Helper function","title":"Flux3D.normalize!","text":"normalize!(pcloud::PointCloud)\n\nNormalize the PointCloud pcloud with mean centered at origin and unit standard deviation and overwrite the pcloud with normalized PointCloud.\n\nSee also: normalize\n\nExamples:\n\njulia> p = PointCloud(rand(1024,3))\njulia> normalize!(p)\n\n\n\n\n\n","category":"method"},{"location":"api/utils/#Flux3D.normalize-Tuple{PointCloud}","page":"Helper function","title":"Flux3D.normalize","text":"normalize(pcloud::PointCloud)\n\nNormalize the PointCloud pcloud with mean centered at origin and unit standard deviation\n\nSee also: normalize!\n\nExamples:\n\njulia> p = PointCloud(rand(1024,3))\njulia> p = normalize(p)\n\n\n\n\n\n","category":"method"},{"location":"api/utils/#Flux3D.realign!-Tuple{PointCloud,AbstractArray{Float32,2},AbstractArray{Float32,2}}","page":"Helper function","title":"Flux3D.realign!","text":"realign!(src::PointCloud, tgt::PointCloud)\nrealign!(src::PointCloud, tgt_min::AbstractArray{<:Number,2}, tgt_max::AbstractArray{<:Number,2})\n\nRe-Align the PointCloud src with the axis aligned bounding box of PointCloud tgt and overwrite pcloud with re-aligned PointCloud.\n\nPointCloud src and tgt should be of same dimension.\n\nSee also: realign\n\nExamples:\n\njulia> src = PointCloud(rand(1024,3))\njulia> tgt = PointCloud(rand(1024,3))\njulia> realign!(src, tgt)\n\n\n\n\n\n","category":"method"},{"location":"api/utils/#Flux3D.realign-Tuple{PointCloud,AbstractArray{var\"#s85\",2} where var\"#s85\"<:Number,AbstractArray{var\"#s84\",2} where var\"#s84\"<:Number}","page":"Helper function","title":"Flux3D.realign","text":"realign(src::PointCloud, tgt::PointCloud)\nrealign(src::PointCloud, tgt_min::AbstractArray{<:Number,2}, tgt_max::AbstractArray{<:Number,2})\n\nRe-Align the PointCloud src with the axis aligned bounding box of PointCloud tgt.\n\nPointCloud src and tgt should be of same dimension.\n\nSee also: realign!\n\nExamples:\n\njulia> src = PointCloud(rand(1024,3))\njulia> tgt = PointCloud(rand(1024,3))\njulia> src = realign!(src, tgt)\n\n\n\n\n\n","category":"method"},{"location":"api/utils/#Flux3D.rotate!-Tuple{PointCloud,AbstractArray{Float32,2}}","page":"Helper function","title":"Flux3D.rotate!","text":"rotate!(pcloud::PointCloud, rotmat::AbstractArray{Number,2})\nrotate!(pcloud::PointCloud, rotmat::AbstractArray{Number,3})\n\nRotate the PointCloud pcloud by rotation matrix rotmat and overwrite pcloud with rotated PointCloud.\n\nRotation matrix rotmat should be of size (3,3) or (3,3,B) where B is the batch size of PointCloud.\n\nSee also: rotate\n\nExamples:\n\njulia> p = PointCloud(rand(1024,3))\njulia> rotmat = rand(3,3)\njulia> rotate!(p, rotmat)\n\n\n\n\n\n","category":"method"},{"location":"api/utils/#Flux3D.rotate-Tuple{PointCloud,AbstractArray{var\"#s86\",N} where N where var\"#s86\"<:Number}","page":"Helper function","title":"Flux3D.rotate","text":"rotate(pcloud::PointCloud, rotmat::Array{<:Number})\n\nRotate the PointCloud pcloud by rotation matrix rotmat.\n\nRotation matrix rotmat should be of size (3,3)\n\nSee also: rotate!\n\nExamples:\n\njulia> p = PointCloud(rand(1024,3))\njulia> rotmat = rand(3,3)\njulia> p = rotate(p, rotmat)\n\n\n\n\n\n","category":"method"},{"location":"api/utils/#Flux3D.scale!-Tuple{PointCloud,Float32}","page":"Helper function","title":"Flux3D.scale!","text":"scale!(pcloud::PointCloud, factor::Number)\n\nScale the PointCloud pcloud by scaling factor factor and overwrite pcloud with scaled PointCloud.\n\nScaling factor factor should be strictly greater than 0.0.\n\nSee also: scale\n\nExamples:\n\njulia> p = PointCloud(rand(1024,3))\njulia> scale!(p, 1.0)\n\n\n\n\n\n","category":"method"},{"location":"api/utils/#Flux3D.scale-Tuple{PointCloud,Float32}","page":"Helper function","title":"Flux3D.scale","text":"scale(pcloud::PointCloud, factor::Number)\n\nScale the PointCloud pcloud by scaling factor factor.\n\nScaling factor factor should be strictly greater than 0.0.\n\nSee also: scale!\n\nExamples:\n\njulia> p = PointCloud(rand(1024,3))\njulia> p = scale(1.0)\n\n\n\n\n\n","category":"method"},{"location":"rep/trimesh/","page":"TriMesh","title":"TriMesh","text":"CurrentModule = Flux3D","category":"page"},{"location":"rep/trimesh/#TriMesh-Structure","page":"TriMesh","title":"TriMesh Structure","text":"","category":"section"},{"location":"rep/trimesh/#Heterogenous-Batching","page":"TriMesh","title":"Heterogenous Batching","text":"","category":"section"},{"location":"rep/trimesh/","page":"TriMesh","title":"TriMesh","text":"Since triangle mesh is heterogeneous in nature, TriMesh follows heterogeneous batching, which include three different representations. Assuming, m = TriMesh([v1, v2], [f1, f2]) where size of v1 is 3 x V1 and v2 is 3 x V2.","category":"page"},{"location":"rep/trimesh/","page":"TriMesh","title":"TriMesh","text":"List      - list of arrays in the batch. Like, get_verts_list(m) returns list of arrays of verts in the batch, [v1, v2]. \nPacked    - Packed representation concatenates the list of arrays in the batch into single packed array. Like, get_verts_packed(m) returns an array of size 3 x (V1+V2).\nPadded    - Padded representation stack up the list of arrays after padding extra values. Like, get_verts_padded(m) returns an array of size 3 x max(V1,V2) x 2 and extra values are filled with 0.","category":"page"},{"location":"rep/trimesh/","page":"TriMesh","title":"TriMesh","text":"","category":"page"},{"location":"rep/trimesh/#List-of-the-TriMesh-constructors-and-all-TriMesh-functions.","page":"TriMesh","title":"List of the TriMesh constructors and all TriMesh functions.","text":"","category":"section"},{"location":"rep/trimesh/","page":"TriMesh","title":"TriMesh","text":"Pages   = [\"trimesh.md\"]","category":"page"},{"location":"rep/trimesh/","page":"TriMesh","title":"TriMesh","text":"","category":"page"},{"location":"rep/trimesh/#TriMesh-Constructors","page":"TriMesh","title":"TriMesh Constructors","text":"","category":"section"},{"location":"rep/trimesh/","page":"TriMesh","title":"TriMesh","text":"TriMesh","category":"page"},{"location":"rep/trimesh/#Flux3D.TriMesh","page":"TriMesh","title":"Flux3D.TriMesh","text":"TriMesh\n\nInitialize Triangle Mesh representation.\n\nFields:\n\nN                       - Batch size of TriMesh.\nV                       - Maximum vertices per mesh in TriMesh.\nF                       - Maximum faces per mesh in TriMesh.\nequalised               - Bool, indicates all mesh have same verts and faces size.\nvalid                   -\noffset                  - Offset indicating number to be added to migrate to 0-indexed system.\n_verts_len              - Number of vertices in each mesh of TriMesh.\n_verts_list             - Vertices in list format.\n_verts_packed           - Vertices in packed format.\n_verts_padded           - Vertices in padded format.\n_faces_len              - Number of faces in each mesh of TriMesh.\n_faces_list             - Vertices in list format.\n_faces_packed           - Vertices in packed format.\n_faces_padded           - Vertices in padded format.\n_edges_packed           - Edges in packed format (according to packed vertices).\n_faces_to_edges_packed  - Faces formed by edges in packed format (according to packed edges).\n_laplacian_packed       - Laplacian sparce matrix in packed format.\n_edges_to_key           - Dict mapping edges tuple to unique key.\n\nAvailable Contructor:\n\nTriMesh(verts_list, faces_list; offset::Number = -1)\nTriMesh(m::Vector{<:GeometryBasics.Mesh})\nTriMesh(m::GeometryBasics.Mesh)\nTriMesh(m::TriMesh)\n\n\n\n\n\n","category":"type"},{"location":"rep/trimesh/","page":"TriMesh","title":"TriMesh","text":"","category":"page"},{"location":"rep/trimesh/#Loading-and-Saving-from-file","page":"TriMesh","title":"Loading and Saving from file","text":"","category":"section"},{"location":"rep/trimesh/","page":"TriMesh","title":"TriMesh","text":"load_trimesh\nsave_trimesh","category":"page"},{"location":"rep/trimesh/#Flux3D.load_trimesh","page":"TriMesh","title":"Flux3D.load_trimesh","text":"load_trimesh(fn::String...)\n\nLoad TriMesh from file(s). It will load TriMesh with multiple meshes, if multiple files are given.\n\nSupported formats are obj, stl, ply, off and 2DM.\n\n\n\n\n\n","category":"function"},{"location":"rep/trimesh/#Flux3D.save_trimesh","page":"TriMesh","title":"Flux3D.save_trimesh","text":"save_trimesh(fn::String, mesh::TriMesh, index::Int = 1)\nsave_trimesh(fn::String, mesh::GeometryBasics.Mesh)\n\nSave mesh in given fn. index is an optional argument specifing the index of mesh, incase of multiple meshes in TriMesh mesh.\n\nSupported formats are obj, stl, ply, off and 2DM.\n\n\n\n\n\n","category":"function"},{"location":"rep/trimesh/","page":"TriMesh","title":"TriMesh","text":"","category":"page"},{"location":"rep/trimesh/#Support-for-GeometryBasics.jl","page":"TriMesh","title":"Support for GeometryBasics.jl","text":"","category":"section"},{"location":"rep/trimesh/","page":"TriMesh","title":"TriMesh","text":"TriMesh structure can be converted to and from GeometryBasics.jl Structure.","category":"page"},{"location":"rep/trimesh/","page":"TriMesh","title":"TriMesh","text":"GBMesh\ngbmeshes","category":"page"},{"location":"rep/trimesh/#Flux3D.GBMesh","page":"TriMesh","title":"Flux3D.GBMesh","text":"GBMesh(m::TriMesh; index::Int = 1)\nGBMesh(verts::AbstractArray{T,2}, faces::AbstractArray{R,2}) where {T,R}\n\nInitialize GeometryBasics.Mesh from triangle mesh in TriMesh m at index.\n\nSee also: gbmeshes\n\n\n\n\n\n","category":"function"},{"location":"rep/trimesh/#Flux3D.gbmeshes","page":"TriMesh","title":"Flux3D.gbmeshes","text":"gbmeshes(m::TriMesh)\n\nInitialize list of GeometryBasics.Mesh from TriMesh m\n\nSee also: gbmeshes\n\n\n\n\n\n","category":"function"},{"location":"rep/trimesh/","page":"TriMesh","title":"TriMesh","text":"","category":"page"},{"location":"rep/trimesh/#Vertices-and-Faces","page":"TriMesh","title":"Vertices and Faces","text":"","category":"section"},{"location":"rep/trimesh/","page":"TriMesh","title":"TriMesh","text":"get_verts_list\nget_verts_packed\nget_verts_padded\nget_faces_list\nget_faces_packed\nget_faces_padded","category":"page"},{"location":"rep/trimesh/#Flux3D.get_verts_list","page":"TriMesh","title":"Flux3D.get_verts_list","text":"get_verts_list(m::TriMesh; refresh::Bool = false)\n\nReturns vertices of TriMesh m in list format.\n\nrefresh is an optional keyword argument to recompute this format for TriMesh m.\n\nSee also: get_verts_padded, get_verts_packed\n\nExamples:\n\njulia> m = load_trimesh(\"teapot.obj\")\njulia> get_verts_list(m)\n\n\n\n\n\n","category":"function"},{"location":"rep/trimesh/#Flux3D.get_verts_packed","page":"TriMesh","title":"Flux3D.get_verts_packed","text":"get_verts_packed(m::TriMesh; refresh::Bool = false)\n\nReturns vertices of TriMesh m in packed format.\n\nrefresh is an optional keyword argument to recompute this format for TriMesh m.\n\nSee also: get_verts_padded, get_verts_list\n\nExamples:\n\njulia> m = load_trimesh(\"teapot.obj\")\njulia> get_verts_packed(m)\n\n\n\n\n\n","category":"function"},{"location":"rep/trimesh/#Flux3D.get_verts_padded","page":"TriMesh","title":"Flux3D.get_verts_padded","text":"get_verts_padded(m::TriMesh; refresh::Bool = false)\n\nReturns vertices of TriMesh m in padded format.\n\nrefresh is an optional keyword argument to recompute this format for TriMesh m.\n\nSee also: get_verts_packed, get_verts_list\n\nExamples:\n\njulia> m = load_trimesh(\"teapot.obj\")\njulia> get_verts_padded(m)\n\n\n\n\n\n","category":"function"},{"location":"rep/trimesh/#Flux3D.get_faces_list","page":"TriMesh","title":"Flux3D.get_faces_list","text":"get_faces_list(m::TriMesh; refresh::Bool = false)\n\nReturns faces of TriMesh m in list format.\n\nrefresh is an optional keyword argument to recompute this format for TriMesh m.\n\nSee also: get_faces_padded, get_faces_list\n\nExamples:\n\njulia> m = load_trimesh(\"teapot.obj\")\njulia> get_faces_list(m)\n\n\n\n\n\n","category":"function"},{"location":"rep/trimesh/#Flux3D.get_faces_packed","page":"TriMesh","title":"Flux3D.get_faces_packed","text":"get_faces_packed(m::TriMesh; refresh::Bool = false)\n\nReturns faces of TriMesh m in packed format.\n\nrefresh is an optional keyword argument to recompute this format for TriMesh m.\n\nSee also: get_faces_padded, get_faces_list\n\nExamples:\n\njulia> m = load_trimesh(\"teapot.obj\")\njulia> get_faces_packed(m)\n\n\n\n\n\n","category":"function"},{"location":"rep/trimesh/#Flux3D.get_faces_padded","page":"TriMesh","title":"Flux3D.get_faces_padded","text":"get_faces_padded(m::TriMesh; refresh::Bool = false)\n\nReturns faces of TriMesh m in padded format.\n\nrefresh is an optional keyword argument to recompute this format for TriMesh m.\n\nSee also: get_faces_padded, get_faces_list\n\nExamples:\n\njulia> m = load_trimesh(\"teapot.obj\")\njulia> get_faces_padded(m)\n\n\n\n\n\n","category":"function"},{"location":"rep/trimesh/","page":"TriMesh","title":"TriMesh","text":"","category":"page"},{"location":"rep/trimesh/#Edges,-Laplacian-Matrix-and-other-adjacency-info","page":"TriMesh","title":"Edges, Laplacian Matrix and other adjacency info","text":"","category":"section"},{"location":"rep/trimesh/","page":"TriMesh","title":"TriMesh","text":"get_edges_packed\nget_edges_to_key\nget_faces_to_edges_packed\nget_laplacian_packed\nget_laplacian_sparse","category":"page"},{"location":"rep/trimesh/#Flux3D.get_edges_packed","page":"TriMesh","title":"Flux3D.get_edges_packed","text":"get_edges_packed(m::TriMesh; refresh::Bool = false)\n\nReturns edges of TriMesh m in packed format. Edges are according to the indices of corresponding vertices in get_verts_packed(m)\n\nrefresh is an optional keyword argument to recompute this format for TriMesh m.\n\nSee also: get_verts_packed, get_faces_to_edges_packed\n\nExamples:\n\njulia> m = load_trimesh(\"teapot.obj\")\njulia> get_edges_packed(m)\n\n\n\n\n\n","category":"function"},{"location":"rep/trimesh/#Flux3D.get_edges_to_key","page":"TriMesh","title":"Flux3D.get_edges_to_key","text":"get_edges_to_key(m::TriMesh; refresh::Bool = false)\n\nReturns dict mapping edges (tuple) of TriMesh m to unique key. Edges are according to the indices of corresponding vertices inget_verts_packed(m)\n\nrefresh is an optional keyword argument to recompute this format for TriMesh m.\n\nSee also: get_verts_packed\n\nExamples:\n\njulia> m = load_trimesh(\"teapot.obj\")\njulia> get_edges_to_key(m)\n\n\n\n\n\n","category":"function"},{"location":"rep/trimesh/#Flux3D.get_faces_to_edges_packed","page":"TriMesh","title":"Flux3D.get_faces_to_edges_packed","text":"get_faces_to_edges_packed(m::TriMesh; refresh::Bool = false)\n\nReturns faces of TriMesh m in form of edges. Each edge corresponds to the indices of get_edges_packed(m).\n\nrefresh is an optional keyword argument to recompute this format for TriMesh m. Assuming face f consists of (v1,v2,v3) vertices, and e1 = {v2,v3}, e2 = {v3,v1}, e3 = {v1,v2}, so face f in form of edges would be (e1,e2,e3).\n\nSee also: get_edges_packed\n\nExamples:\n\njulia> m = load_trimesh(\"teapot.obj\")\njulia> get_faces_to_edges_packed(m)\n\n\n\n\n\n","category":"function"},{"location":"rep/trimesh/#Flux3D.get_laplacian_packed","page":"TriMesh","title":"Flux3D.get_laplacian_packed","text":"get_laplacian_packed(m::TriMesh; refresh::Bool = false)\nget_laplacian_sparse(m::TriMesh; refresh::Bool = false)\n\nReturns Laplacian sparce matrix of TriMesh m.\n\nrefresh is an optional keyword argument to recompute this format for TriMesh m.\n\nSee also: laplacian_loss\n\nExamples:\n\njulia> m = load_trimesh(\"teapot.obj\")\njulia> get_laplacian_packed(m)\n\n\n\n\n\n","category":"function"},{"location":"rep/trimesh/#Flux3D.get_laplacian_sparse","page":"TriMesh","title":"Flux3D.get_laplacian_sparse","text":"get_laplacian_packed(m::TriMesh; refresh::Bool = false)\nget_laplacian_sparse(m::TriMesh; refresh::Bool = false)\n\nReturns Laplacian sparce matrix of TriMesh m.\n\nrefresh is an optional keyword argument to recompute this format for TriMesh m.\n\nSee also: laplacian_loss\n\nExamples:\n\njulia> m = load_trimesh(\"teapot.obj\")\njulia> get_laplacian_packed(m)\n\n\n\n\n\n","category":"function"},{"location":"rep/trimesh/","page":"TriMesh","title":"TriMesh","text":"","category":"page"},{"location":"rep/trimesh/#Normals-for-verts/faces-and-faces-areas","page":"TriMesh","title":"Normals for verts/faces and faces areas","text":"","category":"section"},{"location":"rep/trimesh/","page":"TriMesh","title":"TriMesh","text":"compute_verts_normals_list\ncompute_verts_normals_packed\ncompute_verts_normals_padded\ncompute_faces_normals_list\ncompute_faces_normals_packed\ncompute_faces_normals_padded\ncompute_faces_areas_list\ncompute_faces_areas_packed\ncompute_faces_areas_padded","category":"page"},{"location":"rep/trimesh/#Flux3D.compute_verts_normals_list","page":"TriMesh","title":"Flux3D.compute_verts_normals_list","text":"compute_verts_normals_list(m::TriMesh)\n\nComputes Unit normal of vertices of TriMesh m in list format.\n\nrefresh is an optional keyword argument to recompute this format for TriMesh m. Normal vec of each vertex is weighted sum of normals of adjacent faces, weighted by corresponding faces areas and then normalize to unit vector.\n\nSee also: compute_verts_normals_padded, compute_verts_normals_packed\n\nExamples:\n\njulia> m = load_trimesh(\"teapot.obj\")\njulia> compute_verts_normals_list(m)\n\n\n\n\n\n","category":"function"},{"location":"rep/trimesh/#Flux3D.compute_verts_normals_packed","page":"TriMesh","title":"Flux3D.compute_verts_normals_packed","text":"compute_verts_normals_packed(m::TriMesh)\n\nComputes Unit normal of vertices of TriMesh m in packed format.\n\nrefresh is an optional keyword argument to recompute this format for TriMesh m. Normal vec of each vertex is weighted sum of normals of adjacent faces, weighted by corresponding faces areas and then normalize to unit vector.\n\nSee also: compute_verts_normals_padded, compute_verts_normals_list\n\nExamples:\n\njulia> m = load_trimesh(\"teapot.obj\")\njulia> compute_verts_normals_packed(m)\n\n\n\n\n\n","category":"function"},{"location":"rep/trimesh/#Flux3D.compute_verts_normals_padded","page":"TriMesh","title":"Flux3D.compute_verts_normals_padded","text":"compute_verts_normals_padded(m::TriMesh)\n\nComputes Unit normal of vertices of TriMesh m in padded format.\n\nrefresh is an optional keyword argument to recompute this format for TriMesh m. Normal vec of each vertex is weighted sum of normals of adjacent faces, weighted by corresponding faces areas and then normalize to unit vector.\n\nSee also: compute_verts_normals_packed, compute_verts_normals_list\n\nExamples:\n\njulia> m = load_trimesh(\"teapot.obj\")\njulia> compute_verts_normals_padded(m)\n\n\n\n\n\n","category":"function"},{"location":"rep/trimesh/#Flux3D.compute_faces_normals_list","page":"TriMesh","title":"Flux3D.compute_faces_normals_list","text":"compute_faces_normals_list(m::TriMesh)\n\nComputes Unit normal of faces of TriMesh m in list format.\n\nrefresh is an optional keyword argument to recompute this format for TriMesh m.\n\nSee also: compute_faces_normals_padded, compute_faces_normals_packed\n\nExamples:\n\njulia> m = load_trimesh(\"teapot.obj\")\njulia> compute_faces_normals_list(m)\n\n\n\n\n\n","category":"function"},{"location":"rep/trimesh/#Flux3D.compute_faces_normals_packed","page":"TriMesh","title":"Flux3D.compute_faces_normals_packed","text":"compute_faces_normals_packed(m::TriMesh)\n\nComputes Unit normal of faces of TriMesh m in packed format.\n\nrefresh is an optional keyword argument to recompute this format for TriMesh m.\n\nSee also: compute_faces_normals_padded, compute_faces_normals_list\n\nExamples:\n\njulia> m = load_trimesh(\"teapot.obj\")\njulia> compute_faces_normals_packed(m)\n\n\n\n\n\n","category":"function"},{"location":"rep/trimesh/#Flux3D.compute_faces_normals_padded","page":"TriMesh","title":"Flux3D.compute_faces_normals_padded","text":"compute_faces_normals_padded(m::TriMesh)\n\nComputes Unit normal of faces of TriMesh m in padded format.\n\nrefresh is an optional keyword argument to recompute this format for TriMesh m.\n\nSee also: compute_faces_normals_packed, compute_faces_normals_list\n\nExamples:\n\njulia> m = load_trimesh(\"teapot.obj\")\njulia> compute_faces_normals_padded(m)\n\n\n\n\n\n","category":"function"},{"location":"rep/trimesh/#Flux3D.compute_faces_areas_list","page":"TriMesh","title":"Flux3D.compute_faces_areas_list","text":"compute_faces_areas_list(m::TriMesh)\n\nComputes area of faces of TriMesh m in list format.\n\nrefresh is an optional keyword argument to recompute this format for TriMesh m.\n\nSee also: compute_faces_areas_padded, compute_faces_areas_packed\n\nExamples:\n\njulia> m = load_trimesh(\"teapot.obj\")\njulia> compute_faces_areas_list(m)\n\n\n\n\n\n","category":"function"},{"location":"rep/trimesh/#Flux3D.compute_faces_areas_packed","page":"TriMesh","title":"Flux3D.compute_faces_areas_packed","text":"compute_faces_areas_packed(m::TriMesh)\n\nComputes area of faces of TriMesh m in packed format.\n\nrefresh is an optional keyword argument to recompute this format for TriMesh m.\n\nSee also: compute_faces_areas_padded, compute_faces_areas_list\n\nExamples:\n\njulia> m = load_trimesh(\"teapot.obj\")\njulia> compute_faces_areas_packed(m)\n\n\n\n\n\n","category":"function"},{"location":"rep/trimesh/#Flux3D.compute_faces_areas_padded","page":"TriMesh","title":"Flux3D.compute_faces_areas_padded","text":"compute_faces_areas_padded(m::TriMesh)\n\nComputes area of faces of TriMesh m in padded format.\n\nrefresh is an optional keyword argument to recompute this format for TriMesh m.\n\nSee also: compute_faces_areas_packed, compute_faces_areas_list\n\nExamples:\n\njulia> m = load_trimesh(\"teapot.obj\")\njulia> compute_faces_areas_padded(m)\n\n\n\n\n\n","category":"function"},{"location":"api/visualize/","page":"Visualization","title":"Visualization","text":"CurrentModule = Flux3D","category":"page"},{"location":"api/visualize/#Vusualize-functions","page":"Visualization","title":"Vusualize functions","text":"","category":"section"},{"location":"api/visualize/","page":"Visualization","title":"Visualization","text":"note: Note\nRendering of 3D structure is done using AbstractPlotting. Therefore, for visualization purpose we will be required to install Makie and compatible backend (GLMakie or WGLMakie). To install it simply run ] add Makie in the julia prompt.","category":"page"},{"location":"api/visualize/#Example","page":"Visualization","title":"Example","text":"","category":"section"},{"location":"api/visualize/","page":"Visualization","title":"Visualization","text":"julia> using Flux3D, Makie\n\njulia> Makie.AbstractPlotting.set_theme!(show_axis = false, scale=false)\n\njulia> m = load_trimesh(\"teapot.obj\")\nTriMesh{Float32, UInt32, Array} Structure:\n    Batch size: 1\n    Max verts: 1202\n    Max faces: 2256\n    offset: -1\n    Storage type: Array\n\njulia> p = PointCloud(m)\nPointCloud{Float32} Structure:\n    Batch size: 1\n    Points: 1000\n    Normals 0\n    Storage type: Array{Float32,3}\n\njulia> v = VoxelGrid(m)\nVoxelGrid{Float32} Structure:\n    Batch size: 1\n    Voxels features: 32\n    Storage type: Array{Float32,4}\n\njulia> vbox(visulize(m), visualize(p), visualize(v))","category":"page"},{"location":"api/visualize/","page":"Visualization","title":"Visualization","text":"<p align=\"center\">\n    <img width=600 height=300 src=\"../../assets/visualize.png\">\n</p>","category":"page"},{"location":"api/visualize/#Visualize","page":"Visualization","title":"Visualize","text":"","category":"section"},{"location":"api/visualize/","page":"Visualization","title":"Visualization","text":"visualize","category":"page"},{"location":"api/visualize/#Flux3D.visualize","page":"Visualization","title":"Flux3D.visualize","text":"visualize(pcloud::PointCloud; kwargs...)\n\nVisualize PointCloud pcloud at index.\n\nDimension of points in PointCloud pcloud must be 3.\n\nOptional Arguments:\n\ncolor (Symbol)       - Color of the marker, default :blue\nmarkersize (Number)  - Size of the marker, default npoints(pcloud)/5000\n\n\n\n\n\nvisualize(m::TriMesh, index::Int=1; kwargs...)\n\nVisualize mesh at index in TriMesh m.\n\nOptional Arguments:\n\ncolor (Symbol)       - Color of the marker, default :red\n\n\n\n\n\nvisualize(v::VoxelGrid, index::Int=1; kwargs...)\n\nVisualize voxel at index in VoxelGrid v.\n\nOptional Arguments:\n\ncolor (Symbol)       - Color of the marker, default :red\n\n\n\n\n\n","category":"function"},{"location":"tutorials/dgcnn/#Dynamic-Graph-CNN-Classification","page":"DGCNN classication","title":"Dynamic-Graph CNN Classification","text":"","category":"section"},{"location":"tutorials/dgcnn/","page":"DGCNN classication","title":"DGCNN classication","text":"Classification of PointCloud structure using PointNet model","category":"page"},{"location":"tutorials/dgcnn/","page":"DGCNN classication","title":"DGCNN classication","text":"note: Note\nFor visualization purpose we will require to install Makie and compatible backend (GLMakie or WGLMakie). To install it simply run ] add Makie in the julia prompt.","category":"page"},{"location":"tutorials/dgcnn/","page":"DGCNN classication","title":"DGCNN classication","text":"using Flux3D, Flux, Makie, CUDA\nusing Flux: onehotbatch, onecold, onehot, crossentropy\nusing Statistics: mean\nusing Base.Iterators: partition\n\nMakie.AbstractPlotting.inline!(false)\nMakie.AbstractPlotting.set_theme!(show_axis = false)","category":"page"},{"location":"tutorials/dgcnn/#Defining-arguments-for-use-in-training.","page":"DGCNN classication","title":"Defining arguments for use in training.","text":"","category":"section"},{"location":"tutorials/dgcnn/","page":"DGCNN classication","title":"DGCNN classication","text":"batch_size - batch size of of training data to be passed while training.\nlr - learing rate for the optimization.\nepochs - number of episodes for training the classification model.\nK - k nearest neighbors used in DGCNN model.\nnum_classes - number of classes in labels of dataset.\nnpoints - number of points in each PointCloud to be returned by dataset.","category":"page"},{"location":"tutorials/dgcnn/","page":"DGCNN classication","title":"DGCNN classication","text":"batch_size = 32\nlr = 3e-4\nepochs = 5\nK = 10\nnum_classes = 10\nnpoints = 1024","category":"page"},{"location":"tutorials/dgcnn/#ModelNet10-Dataset","page":"DGCNN classication","title":"ModelNet10 Dataset","text":"","category":"section"},{"location":"tutorials/dgcnn/","page":"DGCNN classication","title":"DGCNN classication","text":"This package has dataset wrapper for ModelNet10/40 which makes it easy to load and preprocess ModelNet dataset. In this example we will using ModelNet10 but we can also use ModelNet40 with minor tweak in num_classes args.","category":"page"},{"location":"tutorials/dgcnn/","page":"DGCNN classication","title":"DGCNN classication","text":"We can construct ModelNet10 dataset by passing:","category":"page"},{"location":"tutorials/dgcnn/","page":"DGCNN classication","title":"DGCNN classication","text":"mode=:pointcloud - for returning PointCloud variant of dataset\nnpoints - no. of points in each PointCloud.\ntransforms  - Transforms to be applied before return specified PointCloud.\ntrain   - Bool to indicate training or testing split.","category":"page"},{"location":"tutorials/dgcnn/","page":"DGCNN classication","title":"DGCNN classication","text":"Detailed list of available arguments can be found in ModelNet section.","category":"page"},{"location":"tutorials/dgcnn/","page":"DGCNN classication","title":"DGCNN classication","text":"dset = ModelNet10.dataset(;\n    mode = :pointcloud,\n    npoints = npoints,\n    transform = NormalizePointCloud(),\n)\nval_dset = ModelNet10.dataset(;\n    mode = :pointcloud,\n    train = false,\n    npoints = npoints,\n    transform = NormalizePointCloud(),\n)","category":"page"},{"location":"tutorials/dgcnn/#Visualizing-the-dataset","page":"DGCNN classication","title":"Visualizing the dataset","text":"","category":"section"},{"location":"tutorials/dgcnn/","page":"DGCNN classication","title":"DGCNN classication","text":"we can access the dataset by correspond index like dset[1] which will return a ModelNet10 DataPoint and following information idx: 1, data: PointCloud{Float32}, ground_truth: 1 (bathtub).","category":"page"},{"location":"tutorials/dgcnn/","page":"DGCNN classication","title":"DGCNN classication","text":"For the visulizing the corresponding datapoint we can use visulize","category":"page"},{"location":"tutorials/dgcnn/","page":"DGCNN classication","title":"DGCNN classication","text":"visualize(dset[11], markersize = 0.1)","category":"page"},{"location":"tutorials/dgcnn/","page":"DGCNN classication","title":"DGCNN classication","text":"<p align=\"center\">\n    <img width=256 height=256 src=\"../../assets/chair.png\">\n</p>","category":"page"},{"location":"tutorials/dgcnn/#Preparing-Dataloader-for-training.","page":"DGCNN classication","title":"Preparing Dataloader for training.","text":"","category":"section"},{"location":"tutorials/dgcnn/","page":"DGCNN classication","title":"DGCNN classication","text":"data = [dset[i].data.points for i = 1:length(dset)]\nlabels =\n    onehotbatch([dset[i].ground_truth for i = 1:length(dset)], 1:num_classes)\n\nvalX = cat([val_dset[i].data.points for i = 1:length(val_dset)]..., dims = 3)\nvalY = onehotbatch(\n    [val_dset[i].ground_truth for i = 1:length(val_dset)],\n    1:num_classes,\n)\n\nTRAIN = [\n    (cat(data[i]..., dims = 3), labels[:, i])\n    for i in partition(1:length(data), batch_size)\n]\nVAL = (valX, valY)","category":"page"},{"location":"tutorials/dgcnn/#Defining-3D-model","page":"DGCNN classication","title":"Defining 3D model","text":"","category":"section"},{"location":"tutorials/dgcnn/","page":"DGCNN classication","title":"DGCNN classication","text":"Flux3D has predefined DGCNN classification model which can be used to train PointCloud dataset","category":"page"},{"location":"tutorials/dgcnn/","page":"DGCNN classication","title":"DGCNN classication","text":"m = DGCNN(num_classes, K, npoints)","category":"page"},{"location":"tutorials/dgcnn/#Defining-loss-and-validating-objectives","page":"DGCNN classication","title":"Defining loss and validating objectives","text":"","category":"section"},{"location":"tutorials/dgcnn/","page":"DGCNN classication","title":"DGCNN classication","text":"loss(x, y) = crossentropy(m(x), y)\naccuracy(x, y) =\n    mean(onecold(cpu(m(x)), 1:num_classes) .== onecold(cpu(y), 1:num_classes))","category":"page"},{"location":"tutorials/dgcnn/#Defining-learning-rate-and-optimizer","page":"DGCNN classication","title":"Defining learning rate and optimizer","text":"","category":"section"},{"location":"tutorials/dgcnn/","page":"DGCNN classication","title":"DGCNN classication","text":"opt = Flux.ADAM(lr)","category":"page"},{"location":"tutorials/dgcnn/#Training-the-3D-model","page":"DGCNN classication","title":"Training the 3D model","text":"","category":"section"},{"location":"tutorials/dgcnn/","page":"DGCNN classication","title":"DGCNN classication","text":"ps = params(m)\nfor epoch = 1:epochs\n    running_loss = 0\n    for d in TRAIN\n        gs = gradient(ps) do\n            training_loss = loss(d...)\n            running_loss += training_loss\n            return training_loss\n        end\n        Flux.update!(opt, ps, gs)\n    end\n    print(\"Epoch: $(epoch), epoch_loss: $(running_loss), accuracy: $(accuracy(VAL...))\\n\")\nend\n@show accuracy(VAL...)","category":"page"},{"location":"tutorials/dgcnn/","page":"DGCNN classication","title":"DGCNN classication","text":"","category":"page"},{"location":"tutorials/dgcnn/","page":"DGCNN classication","title":"DGCNN classication","text":"This page was generated using Literate.jl.","category":"page"},{"location":"rep/voxels/","page":"VoxelGrid","title":"VoxelGrid","text":"CurrentModule = Flux3D","category":"page"},{"location":"rep/voxels/#VoxelGrid-Structure","page":"VoxelGrid","title":"VoxelGrid Structure","text":"","category":"section"},{"location":"rep/voxels/#VoxelGrid-Constructor","page":"VoxelGrid","title":"VoxelGrid Constructor","text":"","category":"section"},{"location":"rep/voxels/","page":"VoxelGrid","title":"VoxelGrid","text":"Modules = [Flux3D]\nPages = [\"src/rep/voxels.jl\"]","category":"page"},{"location":"rep/voxels/#Flux3D.VoxelGrid","page":"VoxelGrid","title":"Flux3D.VoxelGrid","text":"VoxelGrid\n\nInitialize VoxelGrid representation.\n\nvoxels should be Array of size (N, N, N, B) where N is the number of voxels features and B is the batch size of VoxelGrid.\n\nFields:\n\nvoxels      - voxels features of VoxelGrid.\n\nAvailable Contructor:\n\nVoxelGrid(voxels::AbstractArray)\nVoxelGrid(;voxelsAbstractArray)\nVoxelGrid(v::VoxelGrid)\n\n\n\n\n\n","category":"type"},{"location":"datasets/modelnet/","page":"ModelNet","title":"ModelNet","text":"CurrentModule = Flux3D","category":"page"},{"location":"datasets/modelnet/#ModelNet","page":"ModelNet","title":"ModelNet","text":"","category":"section"},{"location":"datasets/modelnet/#ModelNet-Dataset","page":"ModelNet","title":"ModelNet Dataset","text":"","category":"section"},{"location":"datasets/modelnet/","page":"ModelNet","title":"ModelNet","text":"Modules = [Dataset, Flux3D]\nPages = [\"datasets/modelnet/base.jl\"]","category":"page"},{"location":"datasets/modelnet/#Flux3D.Dataset.ModelNet","page":"ModelNet","title":"Flux3D.Dataset.ModelNet","text":"ModelNet\n\nBase ModelNet for MN10/40.\n\nFields:\n\nroot::String                           - Root directory of dataset\npath::String                           - Directory of dataset\ntrain::Bool                            - Specifies the trainset\nlength::Int                            - Length of dataset\ndatapaths::Array                       - Array containing the shape and path for each datapoint\ntransform                              - Transform to be applied to data point\ncategories::Vector{String}             - Categories to be used in dataset\nclasses_to_idx::Dict{String, UInt8}    - Dict mapping from shape name to class_idx\nidx_to_classes::Dict{UInt8, String}    - Dict mapping from class_idx to shape name\n\n\n\n\n\n","category":"type"},{"location":"datasets/modelnet/","page":"ModelNet","title":"ModelNet","text":"","category":"page"},{"location":"datasets/modelnet/#ModelNet-Constructor","page":"ModelNet","title":"ModelNet Constructor","text":"","category":"section"},{"location":"datasets/modelnet/#ModelNet10-Dataset","page":"ModelNet","title":"ModelNet10 Dataset","text":"","category":"section"},{"location":"datasets/modelnet/","page":"ModelNet","title":"ModelNet","text":"Modules = [Dataset, Flux3D]\nPages = [\"datasets/modelnet/mn10.jl\"]","category":"page"},{"location":"datasets/modelnet/#Flux3D.Dataset.ModelNet10-Tuple{}","page":"ModelNet","title":"Flux3D.Dataset.ModelNet10","text":"ModelNet10(;kwargs...)\n\nReturns ModelNet10 dataset.\n\nOptional Key Arguments:\n\n* `root::String=default_root`   - Root directory of dataset\n* `train::Bool=true`            - Specifies the trainset\n* `transform=nothing`           - Transform to be applied to data point.\n* `categories::Vector{String}`  - Specifies the categories to be used in dataset.\n\nExamples:\n\njulia> dset = ModelNet10(train=false)\njulia> typeof(dset[1].data) == TriMesh\n\n\n\n\n\n","category":"method"},{"location":"datasets/modelnet/#ModelNet40-Dataset","page":"ModelNet","title":"ModelNet40 Dataset","text":"","category":"section"},{"location":"datasets/modelnet/","page":"ModelNet","title":"ModelNet","text":"Modules = [Dataset, Flux3D]\nPages = [\"datasets/modelnet/mn40.jl\"]","category":"page"},{"location":"datasets/modelnet/#Flux3D.Dataset.ModelNet40-Tuple{}","page":"ModelNet","title":"Flux3D.Dataset.ModelNet40","text":"ModelNet40(;kwargs...)\n\nReturns ModelNet40 dataset.\n\nOptional Key Arguments:\n\n* `root::String=default_root`   - Root directory of dataset\n* `train::Bool=true`            - Specifies the trainset\n* `transform=nothing`           - Transform to be applied to data point.\n* `categories::Vector{String}`  - Specifies the categories to be used in dataset.\n\nExamples:\n\njulia> dset = ModelNet40(train=false)\njulia> typeof(dset[1].data) == TriMesh\n\n\n\n\n\n","category":"method"},{"location":"api/metrics/","page":"Metrics","title":"Metrics","text":"CurrentModule = Flux3D","category":"page"},{"location":"api/metrics/#Metrics-for-TriMesh-and-PointCloud","page":"Metrics","title":"Metrics for TriMesh and PointCloud","text":"","category":"section"},{"location":"api/metrics/","page":"Metrics","title":"Metrics","text":"sample_points","category":"page"},{"location":"api/metrics/#Flux3D.sample_points","page":"Metrics","title":"Flux3D.sample_points","text":"sample_points(m::TriMesh, num_samples::Int=5000; returns_normals::Bool=false, eps::Number = 1e-6)\n\nUniformly samples num_samples points from the surface of TriMesh m.\n\nreturns_normals is optional keyword argument, to returns normals from respective faces of samples. eps is optional keyword argument for a small number to prevent division by zero for small surface areas.\n\nExamples:\n\njulia> m = load_trimesh(\"teapot.obj\")\njulia> points = sample_points(m, 5000)\njulia> points, normals = sample_points(m, 5000; returns_normals=true)\n\n\n\n\n\n","category":"function"},{"location":"api/metrics/","page":"Metrics","title":"Metrics","text":"Modules = [Flux3D]\nPages = [\"metrics/mesh.jl\", \"metrics/pcloud.jl\"]","category":"page"},{"location":"api/metrics/#Flux3D.edge_loss","page":"Metrics","title":"Flux3D.edge_loss","text":"edge_loss(m::TriMesh, target_length::Number = 0.0)\n\nComputes mean edge length in TriMesh. \n\ntarget_length is the optional arguments for computing edge length. \n\n\n\n\n\n","category":"function"},{"location":"api/metrics/#Flux3D.laplacian_loss-Tuple{TriMesh}","page":"Metrics","title":"Flux3D.laplacian_loss","text":"laplacian_loss(m::TriMesh)\n\nComputes the laplacian smoothning metrics for TriMesh m\n\n\n\n\n\n","category":"method"},{"location":"api/metrics/#Flux3D.chamfer_distance-Tuple{PointCloud,PointCloud}","page":"Metrics","title":"Flux3D.chamfer_distance","text":"chamfer_distance(A::PointCloud, B::PointCloud; w1=1.0, w2=1.0)\n\nComputes the chamfer distance between PointCloud A and B. \n\nw1 and w2 are optional arguments for specifying the weighted mean of between two  pcloud for computing metrics.\n\n\n\n\n\n","category":"method"},{"location":"api/transforms/","page":"Transforms","title":"Transforms","text":"CurrentModule = Flux3D","category":"page"},{"location":"api/transforms/#Transforms","page":"Transforms","title":"Transforms","text":"","category":"section"},{"location":"api/transforms/#Usage","page":"Transforms","title":"Usage","text":"","category":"section"},{"location":"api/transforms/","page":"Transforms","title":"Transforms","text":"Transforms can be applied to corresponding 3D structure. Chain can be used to compose multiple functions/transforms. Same as Flux.Chain.","category":"page"},{"location":"api/transforms/","page":"Transforms","title":"Transforms","text":"Chain also supports indexing and slicing. See Example below.","category":"page"},{"location":"api/transforms/#Example","page":"Transforms","title":"Example","text":"","category":"section"},{"location":"api/transforms/","page":"Transforms","title":"Transforms","text":"julia> t = Chain(ScalePointCloud(2.0), NormalizePointCloud())\nChain(ScalePointCloud(factor=2.0; inplace=true), NormalizePointCloud(;inplace=true))\n\njulia> p = PointCloud(rand(1024,3))\nPointCloud{Float32} Structure:\n    Batch size: 1\n    Points: 3\n    Normals 0\n    Storage type: Array{Float32,3}\n\njulia> t(p) == t[2](t[1](p))\ntrue\n\njulia> m = load_trimesh(\"teapot.obj\")\nTriMesh{Float32, UInt32, Array} Structure:\n    Batch size: 1\n    Max verts: 1202\n    Max faces: 2256\n    offset: -1\n    Storage type: Array\n\njulia> t = NormalizeTriMesh()\nNormalizeTriMesh(;inplace=true)\n\njulia> t(m)\nTriMesh{Float32, UInt32, Array} Structure:\n    Batch size: 1\n    Max verts: 1202\n    Max faces: 2256\n    offset: -1\n    Storage type: Array","category":"page"},{"location":"api/transforms/","page":"Transforms","title":"Transforms","text":"","category":"page"},{"location":"api/transforms/#List-of-all-available-Transforms","page":"Transforms","title":"List of all available Transforms","text":"","category":"section"},{"location":"api/transforms/","page":"Transforms","title":"Transforms","text":"Pages = [\"transforms.md\"]","category":"page"},{"location":"api/transforms/","page":"Transforms","title":"Transforms","text":"","category":"page"},{"location":"api/transforms/#TriMesh-Transforms","page":"Transforms","title":"TriMesh Transforms","text":"","category":"section"},{"location":"api/transforms/","page":"Transforms","title":"Transforms","text":"NormalizeTriMesh\nScaleTriMesh\nRotateTriMesh\nReAlignTriMesh\nTranslateTriMesh\nOffsetTriMesh","category":"page"},{"location":"api/transforms/#Flux3D.NormalizeTriMesh","page":"Transforms","title":"Flux3D.NormalizeTriMesh","text":"NormalizeTriMesh(; inplace::Bool=true)\n\nNormalize TriMesh with mean at origin and unit standard deviation.\n\ninplace is optional keyword argument, to make transformation in-place If inplace is set to false, it will create deepcopy of TriMesh.\n\nSee also: normalize, normalize!\n\n\n\n\n\n","category":"type"},{"location":"api/transforms/#Flux3D.ScaleTriMesh","page":"Transforms","title":"Flux3D.ScaleTriMesh","text":"ScaleTriMesh(factor::Number; inplace::Bool=true)\n\nScale TriMesh with a given scaling factor factor.\n\nfactor should be strictly greater than 0.0 for obvious reason. inplace is optional keyword argument, to make transformation in-place. If inplace is set to false, it will create deepcopy of TriMesh. Given factor, this transform scale each vertices in TriMesh, ie. point = point * factor\n\nSee also: scale, scale!\n\n\n\n\n\n","category":"type"},{"location":"api/transforms/#Flux3D.RotateTriMesh","page":"Transforms","title":"Flux3D.RotateTriMesh","text":"RotateTriMesh(rotmat::AbstractArray{<:Number,2}; inplace::Bool=true)\n\nRotate vertices of TriMesh with a given rotation matrix rotmat.\n\nrotmat must be AbstractArray{<:Number,2} of size (3,3). inplace is optional keyword argument, to make transformation in-place If inplace is set to false, it will create deepcopy of TriMesh. Given rotmat, this transform will rotate each vertices coordinates (ie. x,y,z) in TriMesh.\n\nSee also: rotate, rotate!\n\n\n\n\n\n","category":"type"},{"location":"api/transforms/#Flux3D.ReAlignTriMesh","page":"Transforms","title":"Flux3D.ReAlignTriMesh","text":"ReAlignTriMesh(target::TriMesh; inplace::Bool=true)\n\nRe-Align TriMesh to axis aligned bounding box of mesh at index in TriMesh target.\n\ninplace is optional keyword argument, to make transformation in-place If inplace is set to false, it will create deepcopy of TriMesh.\n\nSee also: realign, realign!\n\n\n\n\n\n","category":"type"},{"location":"api/transforms/#Flux3D.TranslateTriMesh","page":"Transforms","title":"Flux3D.TranslateTriMesh","text":"TranslateTriMesh(vector::AbstractArray{<:Number}; inplace::Bool=true)\n\nTranslate TriMesh with given translation vector.\n\ninplace is optional keyword argument, to make transformation in-place If inplace is set to false, it will create deepcopy of TriMesh.\n\nSee also: translate, translate!\n\n\n\n\n\n","category":"type"},{"location":"api/transforms/#Flux3D.OffsetTriMesh","page":"Transforms","title":"Flux3D.OffsetTriMesh","text":"OffsetTriMesh(offset_verts::AbstractArray{<:Number,2}; inplace::Bool=true)\n\nAdd offset to the TriMesh by given offset vertices offset_verts\n\ninplace is optional keyword argument, to make transformation in-place If inplace is set to false, it will create deepcopy of TriMesh.\n\nSee also: offset, offset!\n\n\n\n\n\n","category":"type"},{"location":"api/transforms/","page":"Transforms","title":"Transforms","text":"","category":"page"},{"location":"api/transforms/#PointCloud-Transforms","page":"Transforms","title":"PointCloud Transforms","text":"","category":"section"},{"location":"api/transforms/","page":"Transforms","title":"Transforms","text":"NormalizePointCloud\nScalePointCloud\nRotatePointCloud\nReAlignPointCloud","category":"page"},{"location":"api/transforms/#Flux3D.NormalizePointCloud","page":"Transforms","title":"Flux3D.NormalizePointCloud","text":"NormalizePointCloud(; inplace::Bool=true)\n\nNormalize PointCloud with mean at origin and unit standard deviation.\n\ninplace is optional keyword argument, to make transformation in-place If inplace is set to false, it will create deepcopy of PointCloud.\n\nSee also: normalize, normalize!\n\n\n\n\n\n","category":"type"},{"location":"api/transforms/#Flux3D.ScalePointCloud","page":"Transforms","title":"Flux3D.ScalePointCloud","text":"ScalePointCloud(factor::Number; inplace::Bool=true)\n\nScale PointCloud with a given scaling factor factor.\n\nfactor should be strictly greater than 0.0 for obvious reason. inplace is optional keyword argument, to make transformation in-place. If inplace is set to false, it will create deepcopy of PointCloud. Given factor, this transform scale each point in PointCloud, ie. point = point * factor\n\nSee also: scale, scale!\n\n\n\n\n\n","category":"type"},{"location":"api/transforms/#Flux3D.RotatePointCloud","page":"Transforms","title":"Flux3D.RotatePointCloud","text":"RotatePointCloud(rotmat::AbstractArray{<:Number,2}; inplace::Bool=true)\n\nRotate PointCloud with a given rotation matrix rotmat.\n\nrotmat must be AbstractArray{<:Number,2} of size (3,3). inplace is optional keyword argument, to make transformation in-place If inplace is set to false, it will create deepcopy of PointCloud. Given rotmat, this transform will rotate each point coordinates (ie. x,y,z) in PointCloud.\n\nSee also: rotate, rotate!\n\n\n\n\n\n","category":"type"},{"location":"api/transforms/#Flux3D.ReAlignPointCloud","page":"Transforms","title":"Flux3D.ReAlignPointCloud","text":"ReAlignPointCloud(target::PointCloud; inplace::Bool=true)\nReAlignPointCloud(target::AbstractArray{<:Number, 2}; inplace::Bool=true)\n\nRe-Align PointCloud to axis aligned bounding box of target PointCloud.\n\ninput PointCloud and target PointCloud should be of same size. inplace is optional keyword argument, to make transformation in-place If inplace is set to false, it will create deepcopy of PointCloud.\n\nSee also: realign, realign!\n\n\n\n\n\n","category":"type"},{"location":"api/transforms/","page":"Transforms","title":"Transforms","text":"","category":"page"},{"location":"api/transforms/#Conversions-Transforms","page":"Transforms","title":"Conversions Transforms","text":"","category":"section"},{"location":"api/transforms/","page":"Transforms","title":"Transforms","text":"TriMeshToVoxelGrid\nPointCloudToVoxelGrid\nVoxelGridToTriMesh\nPointCloudToTriMesh\nTriMeshToPointCloud\nVoxelGridToPointCloud","category":"page"},{"location":"api/transforms/#Flux3D.TriMeshToVoxelGrid","page":"Transforms","title":"Flux3D.TriMeshToVoxelGrid","text":"TriMeshToVoxelGrid(resolution::Int=32)\n\nConverts a TriMesh to VoxelGrid having specified resolution.\n\nSee also: TriMesh, VoxelGrid\n\n\n\n\n\n","category":"type"},{"location":"api/transforms/#Flux3D.PointCloudToVoxelGrid","page":"Transforms","title":"Flux3D.PointCloudToVoxelGrid","text":"PointCloudToVoxelGrid(resolution::Int=32)\n\nConverts a PointCloud to VoxelGrid having specified resolution.\n\nSee also: PointCloud, VoxelGrid\n\n\n\n\n\n","category":"type"},{"location":"api/transforms/#Flux3D.VoxelGridToTriMesh","page":"Transforms","title":"Flux3D.VoxelGridToTriMesh","text":"VoxelGridToTriMesh(; threshold=0.5, algo=:Exact)\n\nConverts a VoxelGrid to TriMesh.\n\nthreshold is the threshold from which to make binary voxels, and algo is the mode to be used to convert binary voxels. Available algo are [:Exact, :MarchingCubes, :MarchingTetrahedra, :NaiveSurfaceNets].\n\nSee also: TriMesh, VoxelGrid\n\n\n\n\n\n","category":"type"},{"location":"api/transforms/#Flux3D.PointCloudToTriMesh","page":"Transforms","title":"Flux3D.PointCloudToTriMesh","text":"PointCloudToTriMesh(resolution::Int=32)\n\nConverts a PointCloud to TriMesh having specified resolution.\n\nSee also: PointCloud, TriMesh\n\n\n\n\n\n","category":"type"},{"location":"api/transforms/#Flux3D.TriMeshToPointCloud","page":"Transforms","title":"Flux3D.TriMeshToPointCloud","text":"TriMeshToPointCloud(npoints::Int=1000)\n\nConverts a TriMesh to PointCloud having npoints.\n\nSee also: TriMesh, PointCloud\n\n\n\n\n\n","category":"type"},{"location":"api/transforms/#Flux3D.VoxelGridToPointCloud","page":"Transforms","title":"Flux3D.VoxelGridToPointCloud","text":"VoxelGridToPointCloud(npoints::Int=1000; threshold=0.5, algo=:Exact)\n\nConverts a VoxelGrid to PointCloud having npoints.\n\nthreshold is the threshold from which to make binary voxels, and algo is the mode to be used to convert binary voxels. Available algo are [:Exact, :MarchingCubes, :MarchingTetrahedra, :NaiveSurfaceNets].\n\nSee also: PointCloud, VoxelGrid\n\n\n\n\n\n","category":"type"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = Flux3D","category":"page"},{"location":"#Flux3D:-3D-Deep-Learning-Library-in-Julia","page":"Home","title":"Flux3D: 3D Deep Learning Library in Julia","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Flux3D.jl is a 3D vision library, written completely in Julia. This package utilizes Flux.jl and Zygote.jl as its building blocks for training 3D vision models and for supporting differentiation. This package also have support of CUDA GPU acceleration with CUDA.jl.The primary motivation for this library is to provide:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Batched Data structure for 3D data like PointCloud, TriMesh and VoxelGrid for storing and computation.\nTransforms and general utilities for processing 3D structures.\nMetrics for defining loss objectives and predefined 3D models.\nEasy access to loading and pre-processing standard 3D datasets.\nVisualization utilities for PointCloud, TriMesh and VoxelGrid.\nInter-Conversion between different 3D structures.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Any suggestions, issues and pull requests are most welcome.","category":"page"},{"location":"","page":"Home","title":"Home","text":"<p align=\"center\">\n    <img width=450 height=270 src=\"./assets/visualize_anim.gif\">\n</p>","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package is under active development but it is stable enough for use in 3D Machine Learning Research. It has been registered. To install the latest release, type the following in the Julia 1.3+ prompt.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> ] add Flux3D","category":"page"},{"location":"","page":"Home","title":"Home","text":"To install the master branch type the following","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> ] add Flux3D#master","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: Note\nRendering of 3D structure is done using AbstractPlotting. Therefore, for visualization purpose we will be required to install Makie and compatible backend (GLMakie or WGLMakie). To install it simply run ] add Makie in the julia prompt.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Citation","page":"Home","title":"Citation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you use this software as a part of your research or teaching, please cite this github repository. For convenience, we have also provided the bibtex entry in the form of CITATION.bib file in our github repo.","category":"page"},{"location":"","page":"Home","title":"Home","text":"@misc{Suthar2020,\n    author = {Nirmal Suthar, Avik Pal, Dhairya Gandhi},\n    title = {Flux3D: A Framework for 3D Deep Learning in Julia},\n    year = {2020},\n    publisher = {GitHub},\n    journal = {GitHub repository},\n    howpublished = {\\url{https://github.com/FluxML/Flux3D.jl}},\n}","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Contents","page":"Home","title":"Contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"index.md\"]\nDepth = 2","category":"page"},{"location":"#D-Structures","page":"Home","title":"3D Structures","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"rep/pointcloud.md\"\n    \"rep/trimesh.md\"\n    \"rep/voxels.md\"\n]\nDepth = 2","category":"page"},{"location":"#Datasets","page":"Home","title":"Datasets","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"datasets/modelnet.md\"\n    \"datasets/utils.md\"\n]\nDepth = 2","category":"page"},{"location":"#API-Documentation","page":"Home","title":"API Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"api/conversions.md\"\n    \"api/transforms.md\"\n    \"api/metrics.md\"\n    \"api/visualize.md\"\n]\nDepth = 2","category":"page"},{"location":"datasets/utils/","page":"Custom Dataset","title":"Custom Dataset","text":"CurrentModule = Flux3D","category":"page"},{"location":"datasets/utils/#General-Utilities-for-Custom-Dataset","page":"Custom Dataset","title":"General Utilities for Custom Dataset","text":"","category":"section"},{"location":"datasets/utils/","page":"Custom Dataset","title":"Custom Dataset","text":"Modules = [Flux3D, Dataset]\nPages = [\"custom.jl\", \"datasets/utils.jl\"]","category":"page"},{"location":"datasets/utils/#Flux3D.Dataset.CustomDataset","page":"Custom Dataset","title":"Flux3D.Dataset.CustomDataset","text":"CustomDataset\n\nMinimal Custom Dataset. CustomDataset also support indexing and slicing.\n\nFields:\n\nlength::Int         - Length of dataset.\ngetdata::Function   - Function which takes idx as input and returns corresponding data\n\nAvailable Contructor:\n\nCustomDataset(length::Int, getdata::Function)\nCustomDataset(;length::Int, getdata::Function)\n\nExamples:\n\njulia> x = rand(10,32)\njulia> getdata(idx) = x[idx,:]\njulia> dset = CustomDataset(size(x,1), getdata)\njulia> [x[1,:], x[2,:]] == dset[1:2]\n\n\n\n\n\n","category":"type"},{"location":"api/models/","page":"3D Models","title":"3D Models","text":"CurrentModule = Flux3D","category":"page"},{"location":"api/models/#D-Deep-Learning-Models","page":"3D Models","title":"3D Deep Learning Models","text":"","category":"section"},{"location":"api/models/#Dynamic-Graph-CNN","page":"3D Models","title":"Dynamic-Graph CNN","text":"","category":"section"},{"location":"api/models/","page":"3D Models","title":"3D Models","text":"DGCNN","category":"page"},{"location":"api/models/#Flux3D.DGCNN","page":"3D Models","title":"Flux3D.DGCNN","text":"DGCNN(num_classes::Int=10, K::Int=10, npoints::Int=1024)\n\nFlux implementation of Dynamic-Graph CNN classification model.\n\nFields:\n\nnum_classes - Number of classes in dataset.\nK           - k nearest neighbour to be used EdgeConv.\nnpoints     - Number of points in input PointCloud.\n\n\n\n\n\n","category":"type"},{"location":"api/models/#PointNet","page":"3D Models","title":"PointNet","text":"","category":"section"},{"location":"api/models/","page":"3D Models","title":"3D Models","text":"PointNet","category":"page"},{"location":"api/models/#Flux3D.PointNet","page":"3D Models","title":"Flux3D.PointNet","text":"PointNet(num_classes::Int=10, hidden_dims::Int=64)\n\nFlux implementation of PointNet classification model.\n\nFields:\n\nnum_classes - Number of classes in dataset.\nhidden_dims - Hiddem dimension in PointNet model.\n\n\n\n\n\n","category":"type"}]
}
