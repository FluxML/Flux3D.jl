<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Supervised 3D reconstruction · Flux3D.jl</title><link rel="canonical" href="https://nirmal-suthar.github.io/Flux3D.jl/tutorials/fit_mesh/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Flux3D.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">Flux3D.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../pointnet/">PointNet classication</a></li><li><a class="tocitem" href="../dgcnn/">DGCNN classication</a></li><li class="is-active"><a class="tocitem" href>Supervised 3D reconstruction</a><ul class="internal"><li><a class="tocitem" href="#Problem-Description:-1"><span>Problem Description:</span></a></li><li><a class="tocitem" href="#Downloading-obj-file-of-sphere-and-dolphin-1"><span>Downloading obj file of sphere and dolphin</span></a></li><li><a class="tocitem" href="#Loading-Triangle-Mesh-1"><span>Loading Triangle Mesh</span></a></li><li><a class="tocitem" href="#Preprocessing-data-1"><span>Preprocessing data</span></a></li><li><a class="tocitem" href="#Visualizing-TriMesh-1"><span>Visualizing TriMesh</span></a></li><li><a class="tocitem" href="#Defining-loss-objective-1"><span>Defining loss objective</span></a></li><li><a class="tocitem" href="#Defining-learning-rate-and-optimizer-1"><span>Defining learning rate and optimizer</span></a></li><li><a class="tocitem" href="#Using-GPU-for-fast-training-[**Optional**]-1"><span>Using GPU for fast training [<strong>Optional</strong>]</span></a></li><li><a class="tocitem" href="#Optimizing-the-offset-array-1"><span>Optimizing the offset array</span></a></li><li><a class="tocitem" href="#Postprocessing-the-predicted-mesh-1"><span>Postprocessing the predicted mesh</span></a></li><li><a class="tocitem" href="#Saving-the-final_mesh-1"><span>Saving the final_mesh</span></a></li><li><a class="tocitem" href="#Finally..-1"><span>Finally..</span></a></li></ul></li></ul></li><li><span class="tocitem">3D Structure</span><ul><li><a class="tocitem" href="../../rep/pointcloud/">PointCloud</a></li><li><a class="tocitem" href="../../rep/trimesh/">TriMesh</a></li></ul></li><li><span class="tocitem">Datasets</span><ul><li><a class="tocitem" href="../../datasets/modelnet/">ModelNet</a></li><li><a class="tocitem" href="../../datasets/utils/">Custom Dataset</a></li></ul></li><li><a class="tocitem" href="../../api/transforms/">Transforms</a></li><li><a class="tocitem" href="../../api/metrics/">Metrics</a></li><li><span class="tocitem">API Documentation</span><ul><li><a class="tocitem" href="../../api/utils/">Helper function</a></li><li><a class="tocitem" href="../../api/visualize/">Visualization</a></li><li><a class="tocitem" href="../../api/models/">3D Models</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Supervised 3D reconstruction</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Supervised 3D reconstruction</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/nirmal-suthar/Flux3D.jl/blob/master/docs/src/tutorials/fit_mesh.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Supervised-3D-Mesh-Reconstruction-1"><a class="docs-heading-anchor" href="#Supervised-3D-Mesh-Reconstruction-1">Supervised 3D Mesh Reconstruction</a><a class="docs-heading-anchor-permalink" href="#Supervised-3D-Mesh-Reconstruction-1" title="Permalink"></a></h1><h2 id="Problem-Description:-1"><a class="docs-heading-anchor" href="#Problem-Description:-1">Problem Description:</a><a class="docs-heading-anchor-permalink" href="#Problem-Description:-1" title="Permalink"></a></h2><p>We are given an initial source shape (sphere in this case) and we want to deform this source shape to fit target shape (dolphin in this case). For this demonstration, we will be using Triangle Mesh for the representation of source and target shape.</p><p>Triangle Mesh has two main components, vertices and faces. Deformation of source shape to fit target shape can be achieved by offsetting source&#39;s vertices to fit target surface. Also, the number of vertices and faces is not equal in source and target shape.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>For visualization purpose we will require to install Makie and compatible backend (GLMakie or WGLMakie). To install it simply run <code>] add Makie</code> in the julia prompt.</p></div></div><pre><code class="language-julia">using Flux3D, Zygote, Flux, FileIO, Statistics, Plots
using AbstractPlotting, GLMakie

Flux3D.AbstractPlotting.inline!(true)
Flux3D.AbstractPlotting.set_theme!(show_axis = false)</code></pre><h2 id="Downloading-obj-file-of-sphere-and-dolphin-1"><a class="docs-heading-anchor" href="#Downloading-obj-file-of-sphere-and-dolphin-1">Downloading obj file of sphere and dolphin</a><a class="docs-heading-anchor-permalink" href="#Downloading-obj-file-of-sphere-and-dolphin-1" title="Permalink"></a></h2><pre><code class="language-julia">download(&quot;https://github.com/nirmalsuthar/public_files/raw/master/dolphin.obj&quot;,
         &quot;dolphin.obj&quot;)
download(&quot;https://github.com/nirmalsuthar/public_files/raw/master/sphere.obj&quot;,
         &quot;sphere.obj&quot;)</code></pre><h2 id="Loading-Triangle-Mesh-1"><a class="docs-heading-anchor" href="#Loading-Triangle-Mesh-1">Loading Triangle Mesh</a><a class="docs-heading-anchor-permalink" href="#Loading-Triangle-Mesh-1" title="Permalink"></a></h2><p>Triangle Mesh is handled by TriMesh in Flux3D. TriMesh also supports batched format, namely padded, packed and list, which allow us to use fast batched operations. We can load TriMesh with load_trimesh function (supports <code>obj</code>, <code>stl</code>, <code>ply</code>, <code>off</code> and <code>2DM</code>)</p><pre><code class="language-julia">dolphin = load_trimesh(&quot;dolphin.obj&quot;)
src = load_trimesh(&quot;sphere.obj&quot;)</code></pre><h2 id="Preprocessing-data-1"><a class="docs-heading-anchor" href="#Preprocessing-data-1">Preprocessing data</a><a class="docs-heading-anchor-permalink" href="#Preprocessing-data-1" title="Permalink"></a></h2><p>Preprocessing tgt (dolphin), such that its mean is zero and also scale it according to the bounding box of src (sphere), So that src can converge at greater speed.</p><pre><code class="language-julia">tgt = deepcopy(dolphin)
verts = get_verts_packed(tgt)
center = mean(verts, dims=2)
verts = verts .- center
scale = maximum(abs.(verts))
verts = verts ./ scale
tgt._verts_packed = verts</code></pre><h2 id="Visualizing-TriMesh-1"><a class="docs-heading-anchor" href="#Visualizing-TriMesh-1">Visualizing TriMesh</a><a class="docs-heading-anchor-permalink" href="#Visualizing-TriMesh-1" title="Permalink"></a></h2><p>We will use <code>visualize</code> function for visualizing TriMesh. This function uses <strong>Makie</strong> for plotting. In fact, we can also visualize PointCloud using this function, which makes this function handy dealing with different 3D format.</p><pre><code class="language-julia">Flux3D.AbstractPlotting.vbox(visualize(src), visualize(tgt))</code></pre><p align="center">
    <img width=480 height=270 src="../../src/assets/fitmesh_initial.png">
</p><h2 id="Defining-loss-objective-1"><a class="docs-heading-anchor" href="#Defining-loss-objective-1">Defining loss objective</a><a class="docs-heading-anchor-permalink" href="#Defining-loss-objective-1" title="Permalink"></a></h2><p>Starting from the src mesh, we will deform src mesh by offsetting its vertices (by offset array), such that new deformed mesh is close to target mesh. Therefore, our loss function will optimize the offset array. We will be using the following metrics to define loss objective:</p><ul><li><code>chamfer_distance</code> - the distance between the deformed mesh and target mesh, which is calculated by taking randomly 5000 points from the surface of each mesh and calculating chamfer_distance between these two pointcloud.</li><li><code>laplacian_loss</code> - also known as Laplacian smoothing will act as a regularizer.</li><li><code>edge_loss</code> - this will minimize edges length in deformed mesh, also act as a regularizer.</li></ul><pre><code class="language-julia">function loss_dolphin(x::AbstractArray, src::TriMesh, tgt::TriMesh)
    src = Flux3D.offset(src, x)
    loss1 = chamfer_distance(src, tgt, 5000)
    loss2 = laplacian_loss(src)
    loss3 = edge_loss(src)
    return loss1 + 0.1*loss2 + loss3
end</code></pre><h2 id="Defining-learning-rate-and-optimizer-1"><a class="docs-heading-anchor" href="#Defining-learning-rate-and-optimizer-1">Defining learning rate and optimizer</a><a class="docs-heading-anchor-permalink" href="#Defining-learning-rate-and-optimizer-1" title="Permalink"></a></h2><pre><code class="language-julia">lr = 1.0
opt = Flux.Optimise.Momentum(lr, 0.9)</code></pre><h2 id="Using-GPU-for-fast-training-[**Optional**]-1"><a class="docs-heading-anchor" href="#Using-GPU-for-fast-training-[**Optional**]-1">Using GPU for fast training [<strong>Optional</strong>]</a><a class="docs-heading-anchor-permalink" href="#Using-GPU-for-fast-training-[**Optional**]-1" title="Permalink"></a></h2><p>We can convert the TriMesh structure to GPU or CPU using<code>gpu</code> and <code>cpu</code> function which is exactly the same syntax as Flux.</p><pre><code class="language-julia">tgt = tgt |&gt; gpu
src = src |&gt; gpu
_offset = zeros(Float32, size(get_verts_packed(src))...) |&gt; gpu</code></pre><h2 id="Optimizing-the-offset-array-1"><a class="docs-heading-anchor" href="#Optimizing-the-offset-array-1">Optimizing the offset array</a><a class="docs-heading-anchor-permalink" href="#Optimizing-the-offset-array-1" title="Permalink"></a></h2><p>We first initialize offset array as zeros, hence deformed mesh is equivalent to src mesh (sphere). Next, we calculate loss using this offset array and we compute derivatives wrt. offset array and finally optimize the array.</p><pre><code class="language-julia">@info(&quot;Training...&quot;)
θ = Zygote.Params([_offset])
for itr in 1:2001
    gs = gradient(θ) do
        loss_dolphin(_offset, src, tgt)
    end
    Flux.update!(opt, _offset, gs[_offset])
    if (itr%10 == 1)
        loss = loss_dolphin(_offset, src, tgt)
        @show itr, loss
        save(&quot;src_$(itr).png&quot;, visualize(Flux3D.offset(src, _offset)))
    end
end

anim = @animate for i ∈ 1:8
    Plots.plot(load(&quot;src_$(1+250*(i-1)).png&quot;), showaxis=false)
end
gif(anim, &quot;src_deform.gif&quot;, fps = 2)</code></pre><p align="center">

    <img width=256 height=256 src="../../src/assets/fitmesh_anim.gif">
</p><h2 id="Postprocessing-the-predicted-mesh-1"><a class="docs-heading-anchor" href="#Postprocessing-the-predicted-mesh-1">Postprocessing the predicted mesh</a><a class="docs-heading-anchor-permalink" href="#Postprocessing-the-predicted-mesh-1" title="Permalink"></a></h2><p>We create a new TriMesh by offsetting src by final offset array and scale up the final<em>mesh by the same scaling factor we scale down tgt, such that final</em>mesh has similar bounding box as dolphin mesh.</p><pre><code class="language-julia">final_mesh = Flux3D.offset(src, _offset)
final_mesh = Flux3D.scale!(final_mesh, scale)</code></pre><h2 id="Saving-the-final_mesh-1"><a class="docs-heading-anchor" href="#Saving-the-final_mesh-1">Saving the final_mesh</a><a class="docs-heading-anchor-permalink" href="#Saving-the-final_mesh-1" title="Permalink"></a></h2><p>Flux3D provide IO function <code>save_trimesh</code>  to save TriMesh (supports <code>obj</code>, <code>stl</code>, <code>ply</code>, <code>off</code> and <code>2DM</code>)</p><pre><code class="language-julia">save_trimesh(&quot;results/final_mesh.off&quot;, final_mesh)
save(&quot;results/final_mesh.png&quot;, visualize(final_mesh))
Flux3D.AbstractPlotting.vbox(visualize(final_mesh), visualize(dolphin))</code></pre><p align="center">
    <img width=480 height=270 src="../../src/assets/fitmesh_final.png">
</p><h2 id="Finally..-1"><a class="docs-heading-anchor" href="#Finally..-1">Finally..</a><a class="docs-heading-anchor-permalink" href="#Finally..-1" title="Permalink"></a></h2><ul><li>Look into the other examples in <code>examples/</code></li><li>Read more the TriMesh in TriMesh section in documentation and</li></ul><p>Metrics/Transforms section for manipulating TriMesh and computing standard metrics.</p><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../dgcnn/">« DGCNN classication</a><a class="docs-footer-nextpage" href="../../rep/pointcloud/">PointCloud »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 3 August 2020 01:16">Monday 3 August 2020</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
